<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[html2canvas]]></title>
    <url>%2F2018%2F04%2F09%2Fnew%2Fhtml2canvas%2F</url>
    <content type="text"><![CDATA[前言网页截图这个需求之前也有遇到，虽然做了个小 demo，用 canvas 可以生成图片，但是没有具体去看细节，还是有很多坑 原理截图功能原理基本就是通过 canvas 提供了一个 api，canvas.toDataUrl()，通过它可以将 canvas 的内容转化为 base64 的格式，另外还有一个 api 是转化为 blob 格式，canvas.toBlob()。所以我们将 dom 上需要截屏的区域画到 canvas 上后，再保存为数据，之后 new Image，当作 src 传进去就可以生成图片了。 canvas.toDataURL(type, encoderOptions)第一个字符串参数是保存的类型，默认为 image/png，第二个是保存的质量，默认为 0.92 canvas.toBlob(callback, type, encoderOptions)callback,回调函数，可获得一个单独的Blob对象参数。第二，三个参数同上 html2canvas地址 123html2canvas(document.body).then(function(canvas) &#123; document.body.appendChild(canvas);&#125;); 这个库简化了将 dom 转化为 canvas 上的图像一过程。同时它也有很多的限制，作者也明确说了这个东西是在实验阶段，不建议用到开发环境。btw需求需要。。 坑它对浏览器有要求，需要支持 promise，用个 ployfill 可以解决 对 css 样式有部分不支持。但是基本够用了 图片生成可能会模糊，网上确实能找到很多办法，其实无非就是将 canvas 元素宽高设大，样式设小，等同与将高倍画布缩小。而且可能是版本问题，网上大部分方法无效【自己生成一个canvas传入】，最后使用大官方提供的属性 scale ，其实感觉这个属性也不是很好用， 测试就只有设置为 1 的时候效果最好，但是这个最好的效果还是比较模糊 图片需要处理跨域问题，不然就截取不到图片，这个其实是 canvas 的问题 尽管不通过 CORS 就可以在画布中使用图片，但是这会污染画布。一旦画布被污染，你就无法读取其数据。例如，你不能再使用画布的 toBlob(), toDataURL() 或 getImageData() 方法，调用它们会抛出安全错误。这种机制可以避免未经许可拉取远程网站信息而导致的用户隐私泄露。 但是很多对图片都是用的图床 cdn，不方便去设置跨域。所以解决方法一半都是将请求到的图片转化为 base64 后替换图片 src。 另外在一种极限情况下，网页刚打开就去截图的时候，可能会由于图片没有渲染完毕或加载完毕导致截图截的是部分图片 其他奇怪bug。。项目里面设置的一个弹窗竟然会顶导致生成的图片也被顶上去了。。。。此bug没找到原因，最后绕道而行了。。。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动端滚动穿透]]></title>
    <url>%2F2018%2F04%2F09%2Fnew%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%2F</url>
    <content type="text"><![CDATA[前言作移动端项目的时候经常会遇到一个场景，一个全屏幕的遮罩层，然后内部可以滚动，外部不能滚动。讲道理这个需求看起来不麻烦。。。但是意外的实现起来很麻烦。 浏览器行为默认滚动的都是 document.documentElement 这个最外层元素，当内层再出现一个滚动框后滚动行为会变成滚动内层时到达顶部或者底部的时候就去滚动外层元素。 之前在 pc 端时通过 mousewheel 属性的方向以及内部是否滚动到底部和顶部来判断。。现在想起来真是一个蠢方法。。。。 在移动端的时候又遇到了这个问题，然后去搜了下。发现可以采用另一种不同的思路来实现。css 属性的 absolute fixed 属性会默认禁止滚动，利用这个特性就可以很好的去实现这个效果，当遮罩层出现的时候给 body 【或者其他的】元素设置为 fixed，但是这样会丢失滚动记录，fixed不可滚动，所以就需要记录当前屏幕滚动的 scrollTop 值，设置 body 元素的 top，定位过来，当遮罩层消失的时候再设置为 static 就可以完美的实现这个需求了 1234567891011var me = thisvar dom = document.querySelector('#app')if (!me.isShow) &#123; me.scrollTop = document.documentElement.scrollTop || document.body.scrollTop dom.style.position = 'fixed' dom.style.top = `-$&#123;me.scrollTop&#125;px`&#125; else &#123; dom.style.position = 'static' document.body.scrollTop = document.documentElement.scrollTop = me.scrollTop&#125;me.isShow = !me.isShow]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日常小技巧（五）]]></title>
    <url>%2F2018%2F04%2F09%2Fnew%2F%E6%97%A5%E5%B8%B8%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[vue 数据相应之前使用 vue 的时候，对于非跟元素属性的改变不能自动更新这件事情没有什么好对处理方法，都是用对数组方法 push pop splice 这种会改变数组对方法来实现属性对跟新。然后使用这种方法解决大部分问题后就没有继续深入去了解。今天看到一个新对解决方法 vue 中其实提供了相应对解决方法 vue.set vue.delete，后者可能不常用，两者都是可以更新非 vue 实例和根元素下对属性。1234vue.set( target, key, value )&#123;Object | Array&#125; target&#123;string | number&#125; key&#123;any&#125; value vue-router 简便方法当有很多组件对时候不需要一个一个去写了，但是不知道怎么去实现懒加载。12345678910111213141516171819let Modules = require.context("@/components/", true, /\.vue$/)let routesObj = [&#123; path: '/', redirect: '/index',&#125;]Modules.keys().forEach(function (v, i) &#123; let key = v.replace(/(\.\/|\.vue)/g, '') routesObj.push(&#123; path: '/' + key, name: key, component: Modules(v)['default'] &#125;)&#125;)export default new Router(&#123; routes: routesObj&#125;)]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[addEventListener]]></title>
    <url>%2F2018%2F04%2F09%2Fnew%2FaddEventListener%2F</url>
    <content type="text"><![CDATA[前言冬去春来，这段时间真是发生了好多的事情，算是一个新的人生转折点了。换了新城市，新公司，新生活。体验到了北漂生活。这2，3个月过的真是匆匆忙忙。 现在想做的事情有已经堆了有山一样高了，要时有更多对时间就好了 addEventListener这个方法算是最基本的，但是之前去用到的时候还是有疑惑。。。在这里再总结整理下基本结构target.addEventListener(type, listener, options) options一个指定有关 listener 属性的可选参数对象。可用的选项如下：capture: Boolean，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。once: Boolean，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。passive: Boolean，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。mozSystemGroup: 只能在 XBL 或者是 Firefox’ chrome 使用，这是个 Boolean，表示 listener 被添加到 system group。 这里对 capture 就和以前的 useCapture[boolean] 默认 false 值是一样的。都是捕获阶段触发,once 就是这个绑定对事件只执行一次，执行之后就把解绑这个事件passive 基本是为了提高流畅度，以滑动事件举例子。当绑定一个滑动事件之后，我在内部可能执行一段自己的代码，但是对于浏览器来说，它并不知道你的代码里面有没有使用 preventDeafault 事件来组织默认行为，所以浏览器会等待你的代码处理完之后在进行默认行为，这样会造成当你对逻辑很长，且没有使用 preventDeafault 时，浏览器会等待你执行完毕再去滑动，从而造成卡顿，而添加这个 passive 则会告诉浏览器我不会使用 preventDeafault ，从而让滚动这个默认行为不会去等待，也就不会卡顿。 option支持的安全检测在旧版本的DOM的规定中， addEventListener()的第三个参数是一个布尔值表示是否在捕获阶段调用事件处理程序。随着时间的推移，很明显需要更多的选项。与其在方法之中添加更多参数（传递可选值将会变得异常复杂），倒不如把第三个参数改为一个包含了各种属性的对象，这些属性的值用来被配置删除事件侦听器的过程。因为旧版本的浏览器（以及一些相对不算古老的）仍然假定第三个参数是布尔值，你需要编写一些代码来有效地处理这种情况。你可以对每一个你感兴趣的options值进行特性检测。 1234567891011var passiveSupported = false;try &#123; var options = Object.defineProperty(&#123;&#125;, "passive", &#123; get: function() &#123; passiveSupported = true; &#125; &#125;); window.addEventListener("test", null, options);&#125; catch(err) &#123;&#125; 这段代码确实写的很有意思，突然联想到一个以前看到的有趣项目 Can (a== 1 &amp;&amp; a ==2 &amp;&amp; a==3) ever evaluate to true? 有一个回答就是使用 get 来实现的123456789var val = 0Object.defineProperty(window,'a',&#123; get:function()&#123; return ++val &#125;&#125;)if (a === 1 &amp;&amp; a === 2 &amp;&amp; a === 3) console.log('∑:）') 两者都是通过使用 get ，在 js 去检查目标元素的时候去改变元素来达到目标效果在 addEventListener 中，如果浏览器支持 option 为对象的时候，就会去自动查看里面有没有目标选项 key 的 value，这里就是查看 options 对象的属性 capture once passive 是否存在。当查看 passive 的时候，就会触发对 passive 设置的 get 函数，从而得知浏览器是否支持 passive。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[uuid-uid]]></title>
    <url>%2F2018%2F03%2F21%2Fnew%2Fuuid-uid%2F</url>
    <content type="text"><![CDATA[前言作统计的时候看到 pv 和 uv，很奇怪 pv 到底是怎么算出来的，于是就查了下 uid uuiduid: User Identifier uuid: Universally Unique Identifier uidcookie/sessionuid 的实现，一般来说 uid 都是在用户登陆成功后，服务端会生成一个 uid 用来标志这个用户并返回给客户端，写进 cookie。同时在服务端维护一个数据表存储这个 uid。当用户再次访问时会自动带上这个已经存储在本地的 uid 一并发送给服务端，这样就实现了有状态的登陆控制。 比如拿 github 来做个实验，首次访问时状态是未登录的。它会在 cookie 和 localhost 都写上标志量。再登陆后会设置很多标志，最主要的用户标志就是 user_session 。 另外找了下浏览器端有没有办法自己生成标志，因为上面的标志一旦 cookie 被清除就作废。很不稳定然而找到的感觉都是一些玄学方法。。。都属于是那种取巧的，基本上就是疯狂找出在浏览器中能被js脚本检测数的不同设备之间可能会有的不同标志，然后再组合到一起提高准确率。比如下面说到的一些 —— 来自fingerprintjs2 用户代理语言颜色深度屏幕分辨率时区有会话存储与否有本地存储或没有索引了数据库具有IE特定的’AddBehavior’已打开数据库CPU类平台DoNotTrack或不使用Flash实现的已安装字体的完整列表（维护其顺序，从而增加熵）。使用JS / CSS（侧通道技术）检测到的已安装字体列表可以检测多达500个安装的字体，而无需使用闪光灯帆布指纹WebGL指纹识别插件（包含IE）是否安装AdBlock用户是否篡改了其语言1用户是否篡改了其屏幕分辨率1用户是否篡改了其操作系统1用户是否篡改了浏览器1触摸屏检测和功能像素比例系统用户代理可用的逻辑处理器总数。设备内存 觉的这个东西很不稳。。。。。。 uuiduuid 这个已经有了成熟的方案规范，基本都有库来实现 UUID Version 1：基于时间的UUID基于时间的UUID通过计算当前时间戳、随机数和机器MAC地址得到。由于在算法中使用了MAC地址，这个版本的UUID可以保证在全球范围的唯一性。但与此同时，使用MAC地址会带来安全性问题，这就是这个版本UUID受到批评的地方。如果应用只是在局域网中使用，也可以使用退化的算法，以IP地址来代替MAC地址－－Java的UUID往往是这样实现的（当然也考虑了获取MAC的难度）。 UUID Version 2：DCE安全的UUIDDCE（Distributed Computing Environment）安全的UUID和基于时间的UUID算法相同，但会把时间戳的前4位置换为POSIX的UID或GID。这个版本的UUID在实际中较少用到。 UUID Version 3：基于名字的UUID（MD5）基于名字的UUID通过计算名字和名字空间的MD5散列值得到。这个版本的UUID保证了：相同名字空间中不同名字生成的UUID的唯一性；不同名字空间中的UUID的唯一性；相同名字空间中相同名字的UUID重复生成是相同的。 UUID Version 4：随机UUID根据随机数，或者伪随机数生成UUID。这种UUID产生重复的概率是可以计算出来的，但随机的东西就像是买彩票：你指望它发财是不可能的，但狗屎运通常会在不经意中到来。 UUID Version 5：基于名字的UUID（SHA1）和版本3的UUID算法类似，只是散列值计算使用SHA1（Secure Hash Algorithm 1）算法。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日常小技巧（四）]]></title>
    <url>%2F2018%2F03%2F04%2Fnew%2F%E6%97%A5%E5%B8%B8%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[git sshmac 用 git 的时候，ssh 已经配置过，但是每次还是得输密码 Enter passphrase for key &#39;xxxx&#39;解决方法： ssh-add -K xxxemmmmmmm….竟然不能保存，每回开机都得重新来一次。终极解决方法，在.ssh/文件下，就是放密钥的地方编辑一个config文件，如果没有就新建。输入以下内容1234Host * AddKeysToAgent yes UseKeychain yes IdentityFile /Users/mfw/.ssh/id_rsa gitlab发布模块和npm不同，没有 npm publish，只是在gitlab上新建仓库，然后安装对时候如下面&quot;&lt;module-name&gt;&quot;: &quot;git+ssh://git@git.mydomain.com:Username/Repository#{branch|tag}&quot;, meta/titlemeta 属性也可以被设置document.querySelector(&#39;meta[name=&quot;keywords&quot;]&#39;).content = &#39;your&#39;title 也是 document.querySelector(&#39;title&#39;).innerText fetchfetch 为浏览器 windos 的试验方法，需要配合它的 polyfill 库使用，可通过它去比较简单的构造一个 http 请求，该方法会返回一个 promise 对象从而简化传统的 xhr 。fetch 不会主动发送 cookie，可以手动加上 credentials: ‘include’123456789101112function json(data)&#123; return data.json()&#125;fetch('url',&#123; method:'post', body: _body&#125;).then(json).then(data=&gt;&#123; console,log(data)&#125;).catch() js 创建 script 节点创建节点带 src 属性事，默认是使用带异步加载，即 async=’true’ 判断资源是否加载完毕imgimg.onload css对于是自己创建的 style 节点来说，可以从它的一个属性 node.sheet.cssRules 来判读，当加载 css 完毕后，此属性会自动加载到 style 节点上去，此属性就是 style 的样式 对于通过 link 引入的 css 用这个方法有一定的局限性，谷歌内核不支持，cssRules 为 null，ie 和 火狐则可以查询到 js对于自己创建的 js 节点，可以使用 node.onload || node.onreadystatechange来判断是否加载完1234567891011node.onload = function() &#123; node.onload = null; complete(url);&#125;;node.onreadystatechange = function() &#123; if(/loaded|complete/.test(node.readyState)) &#123; node.onreadystatechange = null; complete(url); &#125;&#125;]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue小技巧]]></title>
    <url>%2F2018%2F02%2F28%2Fnew%2Fvue%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[批量读取模块vue-router123456789let Modules = require.context("./../component/pages", true, /\.vue$/);Modules.keys().forEach(function(v, i) &#123; let key = v.replace(/(\.\/|\.vue)/g, ''); routesObj.push(&#123; path: '/' + key, name: key, component: Modules(v)['default'] &#125;);&#125;); Modules(v)[&#39;default&#39;] 为引入的模块 设置请求域名var url = Vue.config.devtools ? ‘//test.xxx.com/api’ : ‘/api’Vue.http.options.root = url proxyTable解决跨域，会将 请求 localhost 的请求转发1234567891011proxyTable: &#123; '/api': &#123; target: 'http://www.xxx.com/some/api', changeOrigin: true, pathRewrite: &#123; '^/api': '' &#125; &#125;&#125;...$http.get('api') webpack anaylzer可以用來检查哪些文件过大可以优化npm install --save-dev webpack-bundle-analyzer1234var BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin; // ...plugins: [new BundleAnalyzerPlugin()] dom中执行方法1&lt;div v-if="isF"&gt;f()&lt;div&gt; 这种写法很取巧，一般是监听$store.state或者其他数据的时候这么写，其实不正规，还是应该用$store.actions或者mutations来对数据进行监测。 v-for 数据显示开关当有一大推数据且需要对每一条数据设置一个开关时可以这么做在当前组件中12345678910data()&#123; return&#123; switch: new Array(size)&#125;&#125;,methods:&#123; change_switch(index)&#123; this.switch.splice(index,1,this.switch[index])&#125;&#125; 这样做就可以比较方便的为每一条数据设置一个开关。唯一不足是 size 可能不知道，就只能设置一个比较大的数。且开销比直接设置 = [] 大 监听vue数据在 dom 中写三元表达式判断1$store.state.some == any ? func() : else() 这样就可以知道 vuex 数据更改然后进行操作 vue-resource rootvue-resource 中可以设置 url 的公共部分，方便测试转正式在 main.js 中12Vue.http.options.root = url;Vue.http.options.emulateJSON = true; 之后可以通过 vue 实例(vm)来访问vm.$http.options.root 数据渲染vue 的数据绑定渲染对数组和对象的检测是浅复制的检测所以当更改数组或对象的时候需要用到 js 方法 splice push 等]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mac环境]]></title>
    <url>%2F2018%2F02%2F28%2Fnew%2Fmac%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[homebrewmac 下安装各种软件包，通过 npm 的方式来安装，brew install thing brew uninstall thing，而且他会自动关联对应的链接，比较方便 iterm一个命令行工具，比自带的终端好用 命令行操作 mkdir 建立文件夹rm [-rf] 移除文件[文件夹]mv one two target 移动[重命名]文件[夹]clear 清屏ls -a 显示隐藏文件 mac 操作mac 和 linux 系统很像，没有 windows 类的桌面，文件的图形化操作系统。mac 下操作用到命令行会很多，而且会有很多权限问题。 commond + 回车可以唤出应用搜索工具，快速打开commond 键相当与 windows 的 ctrl双指触摸板点击 等于右键点击commond + z 撤回commond + shift + z 反撤回commond + ctrl + f 全屏 浏览器 commond + r页面刷新双指操作左右滑动前进后退 更改用户emmmm，这个特别坑，本来是想改登陆账户的名字，在用户和群组里面试着改了一下，结果把账号权限改没了。。然后登陆也登不上。后来网上找了个办法12345按开机键的时候按住 command+s 出现命令行终端的时候按照以下顺序输入命令： /sbin/mount -uaw rm var/db/.applesetupdone reboot .DS_Storemac 隐藏文件。。很可能不小心就给传 git 上去了， 删除项目中的.DS_Store 123456789find . -name .DS_Store -print0 | xargs -0 git rm -f –ignore-unmatch 将 .DS_Store 加入到 .gitignoreecho .DS_Store &gt;&gt; ~/.gitignore 更新项目git add –allgit commit -m ‘.DS_Store banished!’ 给 git 添加全局配置在 gitconfig 文件目录下新建一个vim gitignore_global文件，写入忽略 .DS_Store,然后再添加到 gitconfig 中，添加方式有两种，一种直接打开 gitconfig 文件，写入 12[core] excludesfile = /Users/you/.gitignore_global 或者再命令行中输入1git config --global core.excludesfile ~/.gitignore_global]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[专精]]></title>
    <url>%2F2018%2F02%2F17%2F%E5%8F%B9%E8%A8%80%2F%E4%B8%93%E7%B2%BE%2F</url>
    <content type="text"><![CDATA[晚上看三月的狮子的时候，桐山狮子王战败后听米津玄师的 orion 的时候。男主角在雨里的画面让我突然想起以前有过人说过这样一句话特别喜欢下雨天不打伞，迎着雨踩着水回家。以前完全不能理解，但是突然感觉有那么点羡慕那种。 番里面有这么一句话，希望能有没有逃避的记忆。听到这句话真是深有感触。因为我对自己也说不出相信自己，你已经尽全力了这种话。仔细想想20多年来拼尽全力去做的事情好像真的没有，所有的事情差不多都是3分钟热度，之后就会自己犒劳自己，安慰自己说自己已经努力过了，稍微放松下劳逸结合才对。而且自己也是讨厌努力的人，于是就会放松下来。在3分钟的热度之后就会变得一直不温不热的状态，甚至是一不小心没燃料就会冷下去。 个人觉得那些为某件事情拼尽全力的人很闪耀，kirakira 一样。但是自己就像是羡慕这太阳的星星一样，对于太阳永远接近不了，而且自己的微光也随时会断掉一样。因为那样的事情做不来，那样的人因为性格也接近不了，只能在一旁看着而已。就是所谓在台下bb的吃瓜群众。 在山上闲逛的时候有想过这个问题，自己接近不了太阳的话，那自己成为太阳如何。自己只要在某一方面做的很好之后应该也可以 kirakira 。现在可以做的只要三方面，编程，电吉他，板绘。板绘自己可能真没什么天赋，而且太费时间划掉。编程和电吉他比较喜欢电吉他，但是编程是本质工作而且自己的电吉他水平稀烂。emmmmmmmmmmmmmmmmmmmmm，这两个都想要啊。所以两者就平分吧。时间就从游戏里面扣出来。游戏不能再和以前一样花太多时间在上面。有些时间完全是浪费，比如打守望一输再输之后就不服气，想看看到底能掉多少。。。到最后掉到鱼塘完全没有感情波动了还在继续打，这种完全就是浪费，玩游戏应该是快乐的才对。以后需要注意这些。相应的自控也得加强，不然这些都是废话。。。。= = 之后的一年时间，不，半年时间要拿出成效来。想要更波澜壮阔的人生，想要成为主角。]]></content>
      <categories>
        <category>叹言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面筋]]></title>
    <url>%2F2018%2F02%2F08%2F%E5%8F%B9%E8%A8%80%2F%E9%9D%A2%E7%AD%8B%2F</url>
    <content type="text"><![CDATA[感叹冬去春来，总算是把工作的事情稳定下来了，算是对半年前自己有了一个交代。接下来一定会是更加波澜壮阔的人生。其实毕业的时候就有想过换工作的事情，但是当时的自己贪图安逸就没有去做这些，而是想着推迟到年尾。不过，既然结尾是好的话，过程也不是那么重要 前端题目事件 什么是事件模型 什么是事件委托 target currentTarget 作用域 什么是闭包【具体题目】 123456789101112var foo = function()&#123; var a = 0 return function()&#123; return a++ &#125;&#125;var a = foo()a()a()var b = foo()b()// 0 1 0 let var 变量提升【函数表达式和函数声明区别】 this 1234567891011var foo = &#123; a: 1, bar()&#123; console.log(this.a) &#125;&#125;var bar = foo.barfoo.bar()bar()// 1 undefined// 改进输出1 `var bar = foo.bar.bind(foo)` bind apply call 123456// log 传多参数并再其前面加上一个 'hello'var log = function(...args)&#123; var _args = [].slice.call(args) _args.unshift('hello') console.log.apply(console,args)&#125; 1234567// 实现一个 bindvar bind = function(context)&#123; var me = this return function()&#123; me.apply(context,arguments) &#125;&#125; 异步 js 事件队列，异步队列 web worker promise async/await 123456789101112function async foo()&#123; var bar = function()&#123; return promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(1) //reject('err') &#125;,1000) &#125;) &#125; var a = await bar() console.log(a)&#125; 继承 写尽可能多的继承方法，并说明好坏 prototype 是什么 es6 网络 osi 7层及其代表应用 状态码 tcp 握手挥手，为什么不能两次 从输网址到展现发生了什么 优化加载速度 为什么加载 js 会使 dom 停止渲染 jsonp 原理 同源策略 解决跨域，前后端 session cookie 原理，localStorage sessionStorage 样式表 position 几个属性差别，应用场景 display 几个属性差别，应用场景 垂直居中方法 bfc 框架 vue 双向绑定原理 vue 挂载实例在哪个阶段 webpack 基础配置哪些，常用插件是什么 koa 和 express 相比，优点。主要逻辑【中间件】 如何写爬虫 其他 二叉树 链表和数组区别 环形网络 快排 中序遍历 sql tcp/udp 实时通讯【websocket】，实时对战【帧同步】 杂 最近做的项目 最难的项目，如何解决的 提个场景，给解决思路 个人项目爱好，技术博客 招聘信息网站 app主要也是那一些吧，首先第一个网络上的网站和手机 app，个人觉得好用点的就是拉钩了，拉钩的 app 很好用，网页倒是差一点。其他的比如 boss 直聘，智联，大街，100offer，51job都觉得不是很好用。所以主要的工具也就是拉钩 app，一天上限投十个，但是做点简单的任务可以加上线，上传简历这个功能觉得挺好用，不用去填一大堆表单。而且企业搜索比较全，唯一觉得不足的是对一些薪资和年限标注的可能和实际企业要求不是很符合。 某公司招聘页这个基本上每一个做的好点的企业都会在首页的 footer 下有一个加入我们的跳转链接，小点公司可能就是跳拉钩，或者是发邮箱。大一点的可能就需要你去登录注册填表单，超麻烦。而且这种形式被选中看到的机会也少，但是这种形式的话针对性很强，可以先去搜某公司主页，查看具体职位再找其他方式，拉钩或者邮箱投过去 内推这个肯定是最好的方法，找认识的或者朋友的朋友，或者网友等等，这样的机会会大的多，而且内推后不超过一周就会有消息。 招聘流程其实流程大多都是一样，可能有些小差异。看中简历，hr 联系，电面，视频面【不能直接过去的话】，现场面【包括两轮，面试官和 cto ，内容也会有很多不同，面试官主要会问跟职位有关的东西， cto 会问很多其他的问题，包括数据库，数据结构，网络协议这些基本的和一些项目有关的问题】， 最后就是人事沟通。之后就是等了。 参考网站Front-end-Developer-Interview-Questions面试一个前端开发者网络分析参考前端面试常见问题]]></content>
      <categories>
        <category>叹言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日常小技巧(三)]]></title>
    <url>%2F2018%2F01%2F24%2Fnew%2F%E6%97%A5%E5%B8%B8%E5%B0%8F%E6%8A%80%E5%B7%A7(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[withCredentials允许不同域情况下向后端发送 cookie1234var xhr = new XMLHttpRequest();xhr.open('GET', 'http://example.com/', true);xhr.withCredentials = true;xhr.send(null); 9 arr 方法 map 对每一个元素都执行一个方法，并将返回值组成一个新的数组filter 对每个元素都执行一个方法，返回值为 true 的元素组成一个新的数组some 对每个元素都执行一个方法，当其中一个返回为 true 时，此方法返回为 trueevery 对每个元素都执行一个方法，当所有元素都返回为 true 时，此方法返回为 true 8 osi 7 层模型应用层 主要功能 ：用户接口、应用程序 典型设备：网关 典型协议、标准和应用：TELNET, FTP, HTTP 表示层 主要功能 ：数据的表示、压缩和加密 典型设备：网关 典型协议、标准和应用：ASCLL、PICT、TIFF、JPEG、 MIDI、MPEG 会话层 主要功能 ：会话的建立和结束 典型设备：网关 典型协议、标准和应用：RPC、SQL、NFS 、X WINDOWS、ASP 传输层 主要功能 ：端到端控制 典型设备：网关 典型协议、标准和应用：TCP、UDP、SPX 网络层 主要功能 ：路由，寻址 典型设备：路由器 典型协议、标准和应用：IP、IPX、APPLETALK、ICMP 数据链路层 主要功能 ：保证误差错的数据链路 典型设备：交换机、网桥、网卡 典型协议、标准和应用：802.2、802.3ATM、HDLC、FRAME RELAY 物理层 主要功能 ：传输比特流 典型设备：集线器、中继器 典型协议、标准和应用：V.35、EIA/TIA-232 Object.defineProperty，为某个对象新增属性1234567Object.defineProperty(obj, "key", &#123; enumerable: false, // 默认 false，可否被枚举 configurable: false, // 默认 false，可否被配置（删除） writable: false, // 默认 false，可否被修改 value: "static" // 要被定义的值&#125;);定义多个属性 123456789Object.defineProperties(obj, &#123; 'property1': &#123; value: true, writable: true &#125;, 'property2': &#123; value: 'Hello', writable: false &#125; mailto:yourmail.com邮箱协议，在支持的页面会自动调起邮箱程序 object.create这个感觉就是拿来做继承的123456var son = function(name,value)&#123; father.call(this,name) this.value = value&#125;son.prototype = Object.create(father.prototype)son.prototype.constructor = son create 创建的是拷贝，所以更改 son.prototype 不会更改 father 的 prototype object.assign对象的浅复制，方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 jsonp看着挺厉害，其实就是个漏洞。原理其实就是因为 js 的同源策略并没有对带有 src 标签的 dom 请求做限制，比如 img script 。所以就可以用 script 来取巧123456&lt;script&gt; function say(param) &#123; console.log('jsonp'，param) &#125;&lt;/script&gt;&lt;script src="http://127.0.0.1:3000/"&gt;&lt;/script&gt; 第二个脚本服务端直接拼接字符串返回 say(‘data’)，就可以执行 say 输出了 javascript 垃圾回收 分配内存 内存读写 内存回收 在第三部的时候，如何判断哪些是可以回收的是个难点，js 中内置有垃圾自动回收机制，主要有两种，引用技术和标记清除。第一种是判断对象有没有被引用，第二种则是判断对象能不能被获得但是第一种对于一个循环引用的无法判断，现在大多是用的第二种，具体方法是从根元素开始(全局对象)，向下寻找所有对象。然后删除不能获得的对象 事件委托（代理）这个实际上就是通过事件机制（捕获，冒泡）来实现，比如一个场景，ul 下几个 li，与其给每个 li 加事件，也可以直接给 ul 加上事件，通过 target 来判断到底是哪个 li。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日常小技巧(二)]]></title>
    <url>%2F2018%2F01%2F15%2Fnew%2F%E6%97%A5%E5%B8%B8%E5%B0%8F%E6%8A%80%E5%B7%A7(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[触发 bfcfloat的值不为none。overflow的值为auto,scroll或hidden。display的值为table-cell, table-caption, inline-block中的任何一个。position的值不为relative和static inline 元素可以设置 padding，不能设置 margin-top margin-bottompositionfixed 定位当祖先有 transform 属性时，会相对于该祖先定位sticky 新属性，目前兼容还不太好sticky 是 relative 和 fixed 混合的元素，元素在跨越特定阈值前为相对定位，之后为固定定位。他可以很方便的解决滚动覆盖的应用场景 initial inheritinitial 可以理解为不继承，保持原来属性 encodeURI encodeURIComponent后者会把 : / 也转义 currentTarget : 冒泡或捕获触发的目标domtarget : 点击的dom123&lt;div id="fa"&gt;fa &lt;div id="son"&gt;son&lt;/div&gt; &lt;/div&gt; 123456789101112&lt;script&gt; var fa = document.querySelector('#fa') var son = document.querySelector('#son') son.addEventListener('click', function (e) &#123; console.log(e.currentTarget, e.target) console.log('son') &#125;) fa.addEventListener('click', function (e) &#123; console.log(e.currentTarget, e.target) console.log('fa') &#125;)&lt;/script&gt; 冒泡 false 或者 默认1234#son #sonson#fa #sonfa 捕获1234#fa #sonfa#son #sonson url 中 # 以后的部分不会发送给服务端prototypeObject.prototype构造出Function.prototype，然后Function.prototype构造出Object和Function。 new 操作符创建类的实例。它是proto属性设置为的空对象F.prototype。初始化实例。该函数F被传递的参数调用并this设置为实例。返回实例123456789101112function New (f) &#123; /*1*/ var n = &#123; '__proto__': f.prototype &#125;; return function () &#123; /*2*/ f.apply(n, arguments); /*3*/ return n; &#125;; &#125; cookie发送 http 请求时会自动在 header 上带上 cookie，当服务端设置 cookie 之后会自动在客户端写入 cookiesession 和 cookie 差不多，一个在本地一个在服务端，不过 session 也是通过 req header cookie 来进行查找判断找出对应状态从而实现有状态的cookie 设置12345678maxAge: a number representing the milliseconds from Date.now() for expirysigned: sign the cookie valueexpires: a Date for cookie expirationpath: cookie path, /' by defaultdomain: cookie domainsecure: secure cookiehttpOnly: server-accessible cookie, true by defaultoverwrite: a boolean indicating whether to overwrite previously set cookies of the same name (false by default). If this is true, all cookies set during the same request with the same name (regardless of path or domain) are filtered out of the Set-Cookie header when setting this cookie. npm 实在装不动的时候换淘宝源npm install –registry=http://registry.npm.taobao.org 手机录像和录音不能同时开]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网易2017活动页面学习]]></title>
    <url>%2F2018%2F01%2F02%2Fnew%2F%E7%BD%91%E6%98%932017%E6%B4%BB%E5%8A%A8%E9%A1%B5%E9%9D%A2%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言今天看到空间里都在发这个就也去体验了一下，发现这个页面做的真的很棒，于是就爬了下，记录一些新发现 网页链接 因为之前也做过类似的，所以真的很佩服把这个做到这么好，下面分几个方面去看 数据这个没得说，网易云音乐的大数据做的真的好，这个从推荐喜好音乐就能看出来 数据加载这个页面做的也是一屏一屏的展示，它的数据加载就做的相当好，首先首屏加载了后面所有需要的数据存了起来。并且在首屏就请求了1屏和2屏的图片资源，然后切换到2屏的时候就豪无卡顿的感觉，而且到二屏之后加载三屏的数据，且基本所有的图片都做的是cdn，这样使图片的加载速度更快。 动画这个页面的设计本来就很棒，偏日式的扁平风，然后再配上小清新音乐就给人一个很舒服轻松的感觉，动画也没有用到复杂的 canvas，而是用了 svg 和对大图片的定位来做动画。 图片定位比如这一张游泳的图片，看到这个就瞬间想到了background-position。之前也用到同样的方法去模仿简单的视频，但是没有想到把它当简单的gif来使用。 1 svgsvg这个是用了svg的动画 &lt;animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 0 0" to="360 90 90" dur="8s" repeatCount="indefinite"&gt;&lt;/animateTransform&gt; &lt;animateMotion begin="-1s" dur="4s" rotate="auto" repeatCount="indefinite"&gt; &lt;mpath xlink:href="#a"&gt;&lt;/mpath&gt; &lt;/animateMotion&gt; &lt;path d="M674.09-33.84C342.94 353.33 88.03 549.27-90.66 553.98" id="a"&gt;&lt;/path&gt; 对一些很复杂的动画用一般都是用 gif 或者是 canvas 来做，但是 gif 缺点是比较大而且模糊，canvas 则是复杂切消耗大。用 svg 的话以前觉得是兼容不好，但是看到网易都这么搞了看来也没什么了。 1 其他还有一些动画就是一些比较简单的，图层叠加，应用时间差，利用 transition animation 来做动画，但是它的设计很好，很巧妙布局用了px 百分比布局，并做了不同屏幕终端的适配，最小尺寸 320 * 568整个页面估计用的是 react-cli 写的]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css小技巧]]></title>
    <url>%2F2017%2F12%2F13%2F%E5%B0%BA%E5%B7%A5%2Fcss%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[修改网页标题document.title = ‘’ margin 垂直方向上撑出父元素1234567891011121314151617&lt;div id="box"&gt; &lt;div id="content"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; #box &#123; width: 400px; height: 400px; background: #333; &#125; #content &#123; width: 100px; height: 100px; background: #fff; margin-top: 20px; &#125;&lt;/style&gt; cotent 的 margin-top 会变成父元素的 margin-top这种情况是典型的 marging 在垂直方向上的重叠 解决 父元素添加overflow: auto hiidenpaddingborderposition: absolute fixed 垂直居中和以前的 margin 负值差不多，只不过变成动态计算12345&#123; top: 50%; left: 50%; transform: translate3d(-50%,-50%,0)&#125; 拉伸元素后 margin auto12345678&#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto;&#125; 可编辑divcontenteditable = &quot;true&quot; 可以让普通的 div 进入可编辑模式，但是发现他有一个比较奇怪的特性，当定位 absolute 时，回车换行的出现方式有两种，向上出现和向下出现。修改下方css top 为 bottom 后再按回车 滚动条滚动条在 css3 中有很多自定义的样式，下面的图可以很清楚的说明他们的关系 页面变高时滚动条出现导致网页内容左移1234567891011121314151617html &#123; overflow-y: scroll;&#125;:root &#123; overflow-y: auto; overflow-x: hidden;&#125;:root body &#123; position: absolute;&#125;body &#123; width: 100vw; overflow: hidden;&#125; 高度动画让高度从固定到不固定产生动画效果123456789#box&#123; min-height: 200px; max-height: 200px; transition: all .5s;&#125;#box: hover&#123; max-height: 500px;&#125;]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[svg]]></title>
    <url>%2F2017%2F12%2F08%2Fnew%2Fsvg%2F</url>
    <content type="text"><![CDATA[svg线段动画dasharray 将线段分为实线和虚线，通过合理设置实线虚线长可以实现动画虚线根据需要设的大一点，这样使需要的线段图形部分全部为实线，通过动画实现线段的加载。不过由于线段的设置原因，实际的动画时间可能不会是设置的动画时间，需要根据情况调整可以配合另外的一些现代属性来进行调整 12345678#ani &#123; animation: stroke 2s both infinite; stroke-dasharray: 0 200;&#125;@keyframes stroke&#123;100% &#123; stroke-dasharray: 120 200;&#125; &#125;&#125; svg移动轨迹动画svg 可以沿着某一路线进行移动，这一点是 css3 做不到的animateMotion 中的 path 属性可以定义这一行为其中 rotate 设置为 auto 后，可让图形沿切线移动其他和 css 中的属性差不多 &lt;animateMotion repeatCount=&quot;indefinite&quot; rotate=&quot;auto&quot; path=&quot;M20,25 C 100,25 150,225, 200, 125&quot; dur=&quot;4s&quot; fill=&quot;freeze&quot;&gt;&lt;/animateMotion&gt; svg usesvg 可以直接引用某一块而不用再复制一遍, use 标签里面填写其他 svg 的id就好，但是这个引用过来的元素无法被编辑。123&lt;svg width="40px" height="40px"&gt; &lt;use xlink:href="#ani"/&gt;&lt;/svg&gt;]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[eslint]]></title>
    <url>%2F2017%2F12%2F07%2Fnew%2Feslint%2F</url>
    <content type="text"><![CDATA[前言最近写服务端的时候深感 jshint 不好用。所以换上了 eslint 。 使用一般使用 全局安装 eslint eslint –init eslint your.js vsc下需要安装插件eslint包 使用 vue 的话需要下载eslint-plugin-html,最简单就把脚手架那一套拿过来，开箱即用编辑器设置如下123456"eslint.validate": [ "javascript", "javascriptreact", "vue", "html" ] 规则规则这个东西嘛，，，人多说了算。。 eslint –int 会提示你几种方法，123Answer questions about your styleUse a popular style guideInspect your Javascript file(s) 第一个是比较简单的设置，问你几个问题生成对应的简单配置 第二个用别人家的，会有三种模板选择 123standardgoogleairbnb 从上到下依次变严，一般应该用 standard 就可以 第三个是检测你的文件生成对应规则。不过我没试过 自定义对于生成的配置文件进行修改也比较简单12345678910111213141516171819202122232425262728module.exports = &#123; root: true, parser: 'babel-eslint', parserOptions: &#123; sourceType: 'module' &#125;, env: &#123; browser: true, &#125;, extends: 'standard', // required to lint *.vue files plugins: [ 'html' ], // add your custom rules here rules: &#123; 'curly': 'off', 'no-useless-escape': 'off', 'no-inner-declarations': 'off', 'spaced-comment': 'off', 'camelcase': 'off', 'space-before-function-paren': 'off', // allow async-await 'generator-star-spacing': 'off', // allow debugger during development 'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off' &#125;&#125; 超简版123456789101112131415161718&#123; "extends": [ "standard", "eslint:recommended" ], "env": &#123; "browser": true, "commonjs": true, "es6": true, "node": true &#125;, "parserOptions": &#123; "sourceType": "module" &#125;, "rules": &#123; "eol-last": "off" &#125;&#125; vsc 对eslint支持很好，对有错误的地方说明都很清楚，实在不知道意思也可以拿这关键词去eslint官网查，也有小提示可以自动帮助修复 如果想忽略某些文件的话可以添加 eslintignore 文件，和 gitignore 差不多 之后就开始愉快的受难之旅吧 ∑:(]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[传送]]></title>
    <url>%2F2017%2F12%2F01%2F%E6%9D%82%E4%B9%B1%2F%E4%BC%A0%E9%80%81%2F</url>
    <content type="text"><![CDATA[砰！随手摔上了铁质的门锁，林哲雨使劲跺了跺脚好去适应略不合适的胶鞋。脚下穿的鞋子是公司最近才发下来的，回想起那天穿着橙色标志制服的人事管理对着台下一众穿着白色标志制服的员工，开了三个小时大会去讲这个事情，强调进一步统一大家的着装是为了增加员工的凝聚力，好发展出浓厚的企业文化。嘴角一撇的林哲雨把脑中出现的这些扔到脑后，朝着前方的交通站台走去。 2404年社会的交通方式已经不再是乘车，虽然仍有小部分人坚持这么做，但是大多数人都选择了传送这一简单快捷的方式。人们只需要走到指定的传送装置入口，验证成功后走进去就会被传送到另一个地方。仿佛几世纪前流行的哈利波特小说中所描写的壁炉传送一般的方式刚一出现就受到了很多年轻人的追捧。在这一方式普及成为社会日常交通的过程中，虽然也有过对这一技术的实现表示疑惑的声音和政府的不支持态态。但是随着时间的流逝这些反对和阻挠的也慢慢的消失。大家对这项划时代的技术也慢慢习以为常。林哲雨当时也是因为对这项技术感到好奇而进入到了这家公司。不过可惜的是进来之后从来没真正接近过这项技术，而是一直在开发app。 像往常一样的验证成功后进入到传送机内，林哲雨不耐烦的等待着舱门的关闭，随着光线慢慢暗了下来。闭上了眼睛的自己能感到幽绿的光线正扫描在身上，不到5秒后。自己就应该会出现在公司门口。但是随着舱门的慢慢打开，从里面走出来的林哲雨并没有看见主管那一贯的皱纹臭脸，而是惊讶的发现自己还是在家门口的传送装置前。 装置出问题了！？这是林哲雨的第一反应，自己转身准备重新去传送一遍，在验证身份的时候屏幕上和平时不大一样地在底部出现了一小行400的数字。担心着迟到扣钱的林哲雨没有在意它，直接大踏步走进了装置内。在装置内刚站定的自己突然想起来哪里好像不太对，这个400数字脑中隐约的有过影响。哦，对！刚进公司的时候由于对这项技术非常好奇，自己曾经偷偷的用主管的id卡进入过管理系统查看过一些资料，不过当自己尝试进入一个隐藏并带有密码的文件夹时由于输入密码错误被发现不是本人，直接被系统强制封锁了权限并触发了预警系统。正是由于这件事情导致了自己和主管一起被处罚，所以之后主管也一直对自己摆一张臭脸。那时输入密码错误的时候好像也是在最下行显示了400这个数字！。注意到情况不太对的自己在门马上要关闭的时候险之又险地跳出了装置，不过大衣却不小心给夹在门中。用力往外拽大衣的林哲雨没有想到大衣仿佛没被卡住一般直接拉了出来。由于双手一下子使错了力，一个踉跄倒在了地上。自己惊愕的低头看着手上拽着的大衣，上面有一股烧焦的味道，大衣角上有一道笔直的边缘切线，就仿佛是被激光切割掉一样。 林哲雨心中一阵后怕，立马拿起手机，打开公司的专用系统app去投诉这件事情，但是更奇怪的事情发生了。自己根本就登录不上系统，系统提示[不要重复登录]这不可能！林哲雨在技术部负责的就是app的登录注册和账号管理功能，这个系统提示是自己亲手写的，只有当已经登录后再尝试登录才会有这个提示。当时的自己还曾经向同事开玩笑说，我们的登录是通过眼球和皮肤下植入的芯片做登录确认的，已经登录成功之后怎么可能还有人能再正确输入这些登录状态？除非是一个完全一模一样的克隆人还佩戴着每个人都是唯一绑定的芯片才行吧。。不对，这样也不行啊，芯片的数据是实时更新的，而且克隆这个技术是严厉禁止的，也从来就没有人成功过啊。。。说到底做这个提示到底有什么用啊？。。当时的自己还怀疑过这个脑残的需求文档是不是写错了。 不过此时摸着被整齐切割的大衣边缘的自己想起这个曾经的玩笑却是起了一身的冷汗，难道，现在的我，不再是我？！！ 现在，有两个我！？？ 待续…… ps： 传送技术其实是先复制了所有的粒子信息，然后传送到另一边成功再构造之后清理掉这一边的数据来实现的哦~~(笑) ∑:)]]></content>
      <categories>
        <category>杂乱</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[不肝没钱就真的不能变强吗]]></title>
    <url>%2F2017%2F11%2F25%2F%E5%8F%B9%E8%A8%80%2F%E5%8F%98%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[前言最近无聊又开始看起了主角起点就是占比人类比百分之一的人生赢家类的番，不由的想起当初为什么不喜欢看他的原因就是因为这种伪现实类番的会给我想变成他那样的，想体验那种人生这种很痛苦的梦想，然而这个梦想达成的概率比火星撞地球好小，然而然而就是因为它不为零，才是痛苦产生的根源。 把人生换成游戏来换句话说，困扰我的就是不肝没钱就真的不能变强吗这个严肃的问题 所以本咸鱼今天就特意深思一下这个问题 什么是变强如果把恶心的生活比作有趣的游戏的话，意外的能发现有很多东西是一样的，比如变强。在游戏里的话，变强一分为三种 充钱 爆肝 玄学 说到底怎么去定义变强这件事呢。游戏中的话很好理解，这个概念一出现的时候脑子里立马就能出现答案，网游就是比其他人更强，单机的话就是比怪物更强。或者换句话说比昨天的自己更强，因为有着数值上的直观表现，所以很容易知道自己是不是变强了。 那么现实生活呢？变强要怎么表现？或者说要怎么变成功？ 有更多的钱 有更多的亲友 有能力守护自己想要守护的事物 能做到自己或者他人想让自己做到的事 体验过更丰富的人生 能无所不能 想了想就以上这几种了 氪虽然我没钱，但是我对于钱是必须的而且作用接近万能的程度这一点深信不疑。以前有句老话总是说钱不是万能的，但是这句话很可疑。钱不是万能的大体在于你的原则阻止你为了钱做某件事情，但是原则这个东西真就那么坚固吗？把原则换个说法也就是衡量利益得失的一把天平，左边放上钱和钱能做到的事情，右边放上做这件事的成本和造成的后果影响，这里右边的东西的价值是随着人的认知而不断改变的。 拿钱说事有人会觉得恶俗，没有底线，没有原则。但是把钱换一种形式说，这笔钱能救你重病在床的亲人，让你的事业东山再起，让火箭研发这类高科技得以快速发展呢？ 但是。我没有钱。。 不强是你不够肝现实中的人对于变强来衡量很多是和其他人比，那些看上去就很厉害很成功的人。而不是和过去的自己来比。想拥有别人拥有的东西，但往往求而不得。也难怪，眼界狭窄，鸡汤喝多，被社交网络忽悠，就难免好高骛远，不知自己几斤几两。但是又说回来，想要变强这个想法本身有错吗？不能实现怪自己吗？我觉得更多应该怪这个垃圾游戏，现在的主流观点基本都是你做不到是你不够努力，把大多数你求而不得，失败的东西归结于你自己能力不够，不够努力。这个想法我觉得确实是对的，但是并不能把它加到很多事情上。拿个典型的例子，那些市面上的成功学一碗一碗的鸡汤基本都基于此。拿游戏里的话来说，不够肝是一方面，系统本身辣鸡更是一个原因。各种族阶级的出生各种设定值本来就偏差很大，这些设定除了表现出来的数值，还有不可见上限和下限，以及成长值等等。正是由于这些东西不可见，再加上这个数值系统没有一个明确统一的衡量方法【各个人对它的评定都不同】，导致把这一切都归功于你不努力。这种不强是你不够肝的话我个人觉得是不正确的。 肝然而努力确实是有限的方法中最好用的一个，抛开其他因素，这是每个人都能使用的方法。有很多人通过努力实现了自己的梦想。 但是对我这种咸鱼玩家来说，适度肝是可以的，爆肝那是不可能的。毕竟我个人觉得人生的目的和游戏一样是享受它带来的乐趣而不是痛苦。。爆肝这种本末倒置的行为绝对不会干。。 玄学这玩意说白了就是宗教，虽然看过很多中世纪欧洲里面的对于宗教的描述，但是总觉得这个东西就是通过自欺来达到欺人的效果，这种听天由命的事情还是不想干。。 咸鱼怎么变强？那么对我这种即没钱，又不爆肝，还没信仰的人究竟要怎么才能变强？ 写了这么长我想了这么我还是觉得不可能。。。。。。他喵的 但是，又舍弃不掉这个咸鱼的梦想。 哎，人生就是如此痛苦吧]]></content>
      <categories>
        <category>叹言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[noteOfNode(三)]]></title>
    <url>%2F2017%2F11%2F17%2Fnew%2FnoteOfNode(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[koa之前一直用的是 express-generator 的模板 和 nuxt/express 模板。。总感觉还是得去自己了解下内部的实现方式，老套框架真出了问题又找不到就麻烦了。所以准备用 koa 这个轻型框架来自己搭一个后台系统。 koa 本身和 express 就很像，只不过它更单纯，没有许多的中间件，只是单纯的封装了一些常用方法和 request respoense，与 express 相比，将其中许多的中间件给分离出去，来达到高效，轻量。 特色koa 中一个特色是 async/await (对node版本有要求 node^7.6.0,或者配置 babel)使用也很简单123456789const koa = require('koa')const app = new koa()app.use(async ctx =&gt; &#123; var data await db.find(data) ctx.body = data&#125;)app.listen(3000) 另一个特点就是和 express 一样的中间件系统，中间件的顺序以及传递，错误处理12345678910111213141516app.use(async (ct x,next) =&gt; &#123; var time1 = Date.now() await next() var ms = Date.now() - time1 console.log('ms:' + ms)&#125;)app.use(async ctx =&gt; &#123; //do something&#125;)//err handlerapp.use(async ctx =&gt; &#123; if (404 == ctx.status) &#123; //do something &#125;&#125;) 中间件常用的也就是 koa-static 和 koa-router，文档也很详细，其他插件比如 socket.io axios body-parser mongoose 等 exports module.exportsnode 暂时还不支持 import export ，虽然使用 node --experimental-modules my-app.mjs 可以使用，但是并不方便，而且在这个文件中的 require 也会被改变用法导致加载会不正确，还是需要使用 babel 来进行适配，推荐使用 babel-cli ，开发环境使用 babel-node,生产环境使用编译后的文件。 在 node 中有另外一套文件加载的系统，不同于 es6，它是遵循于 commonJS 的规范，module.exports &amp; require,除了加载库，它也可以加载文件，module.exports 默认导出一个空对象，可以在它上面添加挂载对象，也可以直接赋值1234567891011121314151617b.jsmodule.exports = &#123; a:1, b:function()&#123;&#125;&#125;a.jsvar test = require('./b.js')console.log(test)/* &#123; a:1, b:function&#125;*/ 而 exports 则是一个快捷方式，它只相当于一个变量，有初始赋值 exports = module.exports。所以对于挂载到 exports 上的属性可以被导出，但是赋值给 exports 会导致他不在绑定到 module.exports 上，而不能被导出。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[noteOfNode(二)]]></title>
    <url>%2F2017%2F11%2F14%2Fnew%2FnoteOfNode(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[线程，进程进程是qq，线程是好友窗口单核cpu单线程，多核多线程(系统调度以线程时)进程——资源分配的最小单位，线程——程序执行的最小单位 ###. package-lock.json今天装 npm 包的时候突然出来了这个东西，查了一下是对 package.json 的一个补充，可以去更精准的限制包的版本。 回调写爬虫的时候深感回调的博大精深。。。所以再回去研究研究回调。 promise感觉就是个语法糖，还是回调的原理，只不过写法变的更好了12345678910111213141516171819function getPromise(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(1) resolve(ms) &#125;, ms); &#125;);&#125;var promise = getPromise(100);var promise_ = getPromise(2000);var p = Promise.all([promise, promise_])p.then( (value) =&gt; &#123; console.log(value || 'compelete') &#125;, (error) =&gt; &#123; console.log(error || 'error') &#125;) 添加也可以这么写p.then().catch()这么写更方便看，语义化也更好，第二个 catch 就想当与是 then 中的第二个 function generator。。看不太懂，大概知道这个东西可以单步执行，yiled 同断点一样，通过 next 继续函数的执行，使用需配合 co 这个三方库 async/awiat写法最简单 123456789101112131415async function g() &#123; try &#123; var flag = await new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; &#123; //三种状态 resolve reject pending(处于 pending 的时候会一直等待) resolve(2); //reject(3) &#125;, 1000); &#125;) &#125; catch (err) &#123; console.log('err' + err) &#125; console.log('flag' + flag) // return 'done'&#125; await 后跟 promise 对象，跟一般对象没意义。await 有返回值 flag，不过只返回 resolve 的情况，错误情况需使用 try catch 捕捉，或者对这个 promise 写 then(f1,f_err)但当错误被 then 处理后 try catch 并不会触发。因为此时程序正确执行 1234567g().then(a =&gt; &#123; console.log('g' + a) &#125;, err =&gt; &#123; console.log('gerr' + err) &#125;) async 函数返回的是一个 promise 对象，也通过 .then(f1,f2)可捕捉，函数里的 return 相当于 resolve()，函数里的错误会被传给 reject();]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网易云的hash检测。。]]></title>
    <url>%2F2017%2F11%2F13%2Fnew%2F%E7%BD%91%E6%98%93%E4%BA%91%E7%9A%84hash%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[前言闲着没事爬了下123456789101112131415161718192021222324252627282930function isHashChangeSupported() &#123; var a = "onhashchange", b = a in document.body; return b || (document.body.setAttribute(a, "return;"), b = "function" == typeof document.body[a]), b &amp;&amp; (void 0 === document.documentMode || document.documentMode &gt; 7)&#125;function hashToObject(a) &#123; var b, c, d, e, f, g; if ("[object String]" === Object.prototype.toString.call(a)) &#123; for (0 === a.indexOf("#") &amp;&amp; (a = a.substr(1)), b = &#123;&#125;, c = a.split("&amp;"), f = 0, g = c.length; g &gt; f; f++) d = c[f], e = d.split("="), e[0] &amp;&amp; (b[decodeURIComponent(e[0])] = decodeURIComponent(e[1])); return b &#125;&#125;function onHashChange() &#123; var b, c, d, e; location.hash &amp;&amp; 1 !== location.hash.length &amp;&amp; (b = location.hash.slice(1), c = hashToObject(b), c.to &amp;&amp; c.message &amp;&amp; (d = top.document.getElementById(c.to), e = d.src, d.contentWindow.location.replace(e.replace(/#.*$/, "") + "#" + encodeURIComponent(c.message))))&#125;var monitor = function () &#123; var a = location.href; return function () &#123; var b = location.href; b !== a &amp;&amp; (onHashChange(&#123; type: "hashchange", oldURL: a, newURL: b &#125;), a = b) &#125;&#125;();isHashChangeSupported() ? window.onhashchange = onHashChange : window.setInterval(monitor, 100); 然后去查了一下这个 hashchange，发现了一个新的方法window.addEventListener(&#39;hashchange&#39;,function(){console.log(1)})查了下兼容，辣鸡 ie 不行，其他挺好的感叹做兼容真是辛苦]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[noteOfNode(一)]]></title>
    <url>%2F2017%2F11%2F13%2Fnew%2FnoteOfNode(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[前言最近做 catice 感觉差不多了，虽然2个做的都很糙，只能算是过一遍 api 做出来的东西。然后现在把游戏稍微放一下，开始学习 node。很久之前就有开始看，不过也只是有一些初步的了解，看了些东西，没有实践。对于后端的很多概念和思想都不了解，现在感觉 node 和 js 真是两个语言。。 CPU-bound(计算密集型) 和I/O bound(I/O密集型)对于服务端服务来说，主要分两个类型，一个是需要大量计算，比如人脸识别，小数点精度10的计算以及 ai 智能等，另一个则是大量读取，比如 web 服务器，文件读取返回。对于 node 来说，应该是属于 I/O bound 进程，线程进程：qq，线程：某一个好友窗口线程挂掉会导致进程挂任务分配到多线程速度要比多进程快单一进程（非主进程）不会导致其他进程挂掉 爬虫爬虫作为上手 demo 真是好用，，又能锻炼又还比较有意思。。写这个爬虫的时候也遇到了很多问题。首先请求目标网页获取到返回的 html，并用 cheerio 解析，之后获取 img 标签的 src 属性。node 对文件操作采用的是覆盖式，所以多图片的时候需要考虑命名问题。这里为了方便只获取了有 http 头的外链图片这里踩的第一个坑就是他获取到的并不是真的传统的 dom 节点，而是它封装的格式，必须使用它的解析，而且普通循环对它也没用。。得用它的 each 方法才可以。第二个坑是在 axios 请求数据回来之后的格式，需要增加一个 config responseType: &#39;stream&#39;。。 bug图片在下载之后会有几率随机出现某张（某几张）下载不完整，感觉应该是缓冲区的问题，同时多个 pipe 时出了错。再多去看看文档另外此爬虫获取到的 html 为初始 html，即若有后来的数据注入生成的 img ，并不能取到。某些网站做了反爬虫，多次获取会被禁。。。某些情况下会报错read ECONNRESET，查了下这个应该是访问时连接断掉产生的错误，不知道有什么好的解决办法 完整代码12345678910111213141516171819202122232425262728293031axios.get('https://targetWebsite.com/').then( (res) =&gt; &#123; var imgs_store = []; var $ = cheerio.load(res.data); var imgs = $('img'); imgs.each(function (i, e) &#123; imgs_store.push($(e).attr("src")) &#125;); for (var i in imgs_store) &#123; if (imgs_store[i].slice(0, 4) !== 'http') &#123; imgs_store.splice(i, 1) &#125; &#125; for (let i = 0; i &lt; imgs_store.length; i++) &#123; axios.get(imgs_store[i], &#123; responseType: 'stream' &#125;) .then( (res1) =&gt; &#123; res1.data.pipe(fs.createWriteStream('./img' + i + '.jpg')) &#125;, (res1) =&gt; &#123; console.log(err) &#125; ) &#125; &#125;, (res) =&gt; &#123; console.log('error：' + res) &#125;) 为了尝试解决上次爬虫的图片加载失败，尝试每回进行一个读取操作，操作完成再进行下一个请求。本来考虑的是回调，但是感觉很麻烦所以用了递归函数去操作，虽然这次 http 请求是按次同步执行，但是感觉 pipe 的执行还是异步，所以又尝试给 pipe 加监听。12345678910111213141516171819202122function DownLoad(i, src, max) &#123; if (i == max) return; axios.get(src, &#123; responseType: 'stream' &#125;) .then( (res1) =&gt; &#123; res1.data.pipe(fs.createWriteStream('./img' + i + '.jpg')) res1.data.on('error', (err) =&gt; &#123; console.log('err:' + err) &#125;) res1.data.on('end', () =&gt; &#123; console.log('end:' + i) DownLoad(i + 1, imgs_store[i + 1], max) &#125;); &#125;, (res1) =&gt; &#123; console.log(res1) &#125; )&#125; 然鹅。。。并没有什么用。。。我现在怀疑纯粹是网络原因，因为那个网站是搬用的 pixel 。。。之后我又换成 lofter 的网址，试了两种方式都可以。 放点爬到的猫片他喵的，竟然做了防盗链，访问403，我还是传七牛吧。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日常小技巧]]></title>
    <url>%2F2017%2F11%2F07%2F%E5%B0%BA%E5%B7%A5%2F%E6%97%A5%E5%B8%B8%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[网页截屏html2canvas 可以将某个 dom 转化成 canvas，再转为图片123456789html2canvas(document.querySelector('#box')).then(function (canvas) &#123; var src = canvas.toDataURL("image/png") console.log(src) var img = new Image() img.src = src img.onload = function () &#123; document.body.appendChild(img) &#125; &#125;) 但是它作用有很多限制，对于写在 style 中的 css 样式可能会不生效，必须加到 dom 上 style=””，另外对于部分 css 不支持而且不能实现截屏，只能选中某个 dom 打印输出改变样式 %c 后的部分样式会被改变console.log(‘%c red’,’color: red; font-size:50px’) url 格式&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt; npm i –save存储包并保存到 package.json 的 dependencies 中devDependencies 存放一些依赖工具包，比如 es-lint babel webpack 等 cross-env webpack 包设置不同系统下的 node_env, windows/linux 等 传回调函数去获取异步函数的值1234567var url;function callback(url_) &#123; url = url_;&#125;yibu(callback)//异步函数中callback(url); webpack 中如果想要引用入口文件，设置如下1234entry: &#123; a: "./a", // a requires b b: ["./b"] // workaround: "./b" can now be in another bundle&#125; 这样就可以直接去引用 b 入口文件，加[]就好 文件上传&lt;input type=&quot;file&quot; accept=&quot;image/jpeg,image/jpg,image/png&quot;&gt;选择特定类型文件上传，如果用image/* 的话匹配的会很慢，导致打开很慢 markdown如何前空2格输入法圆角输入2个空格 【圆角切换快捷键 shift+space】 qq表情qq空间评论里输下面的代码可以生成滑稽这个表情。不过不知道这个以后会不会被改掉[em]e248[/em] 滑稽 查询端口占用情况cmd &gt; netstat -ano查询8080端口是否被占用cmd &gt; netstat -ano|]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读取文件]]></title>
    <url>%2F2017%2F11%2F02%2Fnew%2F%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[FileReaderfrom mdnFileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。 其中File对象可以是来自用户在一个&lt;input&gt;元素上选择文件后返回的FileList对象,也可以来自拖放操作生成的 DataTransfer对象,还可以是来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后返回结果. 一般都是通过&lt;input type=file&gt;来选择到文件并进行处理。 filereader 有2个常用的读取函数 readAsDataURL() readAsText() 第一个一般用于读取图片，以 base64 格式展示第二个一般用于读取文本文件，以字符串格式展示 另外和 ajax 一样，它的操作也存在状态，readyState同时有相对于的绑定事件响应123456789101112onabort当读取操作被中止时调用.onerror当读取操作发生错误时调用.onload当读取操作成功完成时调用.onloadend当读取操作完成时调用,不管是成功还是失败.该处理程序在onload或者onerror之后调用.onloadstart当读取操作将要开始之前调用.onprogress在读取数据过程中周期性调用. 一般在绑定 input 的 onchange 事件上以获取文件，然后进行读取，具体操作在读取完成的 onload 中进行操作123456789var reader = new FileReader()//获取文件进行读取input.onchange = function(e)&#123; reader.readAsDataURL(e.target.files[0]);&#125;读取完成reader.onloadend = function(e)&#123; var result = e.target.result;&#125; 图片处理input 中还有一个属性可以规定可以选择的类型accept=&quot;image/gif,image/jpg，image/jpeg,image/png&quot;这样可以只选择图片，不过这个可以更改，还是需要再对文件做判断。 然后通过 filereader 去读成 base64 格式，之后可以做上传图片或者用 canvas 进行编辑再通过 canvas.toDataURL(&quot;image/png&quot;)将整个画布转为 base64 再处理。 关于文件的处理mdn上还有许多例子其中拖拽文件的例子很有意思]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[贪吃蛇(二)]]></title>
    <url>%2F2017%2F10%2F26%2F%E5%B0%BA%E5%B7%A5%2F%E8%B4%AA%E5%90%83%E8%9B%87)%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[queue 组件贪吃蛇中最重要的就是一个跟随队列的实现，即每一个小方块总是跟着前一个的移动，具体逻辑就是保存每一个小块的位置和转动信息，然后下一个块去读取它前面一个的信息，判断之后存入。 实现首先为了保证能取到上一个的值，注册了一个系统来保存信息。 存储结构为数组的数组，第一个数组表示有多少组位置信息，第二个数组表示每一组信息内的详细信息，同时规定一个详细信息的最大长度，超过之后就舍去，避免形成数据特别庞大的数组。123456789101112AFRAME.registerSystem('queue', &#123; init() &#123; var me = this; me.position_recording = []; me.rotation_recording = []; &#125;, add_queue() &#123; var me = this; me.position_recording.push([]); me.rotation_recording.push([]); &#125;,&#125;) 每多一个尾巴新增一个数组记录它的信息。同时给每一个块标上序号，对应其信息存储在数组从小到大的顺序。组件初始化函数如下123456789101112131415161718192021init() &#123; var me = this, current_position = &#123;&#125;, current_rotation = &#123;&#125;; //设置id me._id = me.system.position_recording.length; me.system.add_queue(); //设置初始位置 if (me.data.ishead) &#123; me.Copy(me.el.getAttribute('position'), current_position); me.Copy(me.el.getAttribute('rotation'), current_rotation); &#125; else &#123; current_position = me.system.position_recording[me._id - 1][0]; current_rotation = me.system.rotation_recording[me._id - 1][0]; me.el.setAttribute('position', current_position); me.el.setAttribute('rotation', current_rotation); this.el.setAttribute('visible', true) &#125; me.system.position_recording[me._id].unshift(current_position); me.system.rotation_recording[me._id].unshift(current_rotation);&#125;, 问题1下一个滑块应该取上一个滑块的什么位置,在每一个tick里面，滑块的信息都会跟新并unshift到数组对应的数组中存储，下一个滑块要和前一个滑块保持一定的距离，不能太远也不能太近。 tick 中首先存储信息，存储时对于相同的数据不存储，之后对尾巴进行判断，取上一个盒子的第[frame]个数据进行判读，目标位置和上一个盒子的现在位置是否有一定的距离间隔，没有则保持静止，有间隔之后更新位置并存储 这里出现了一个很大的问题，distance 设置的值要和 frame 设置的值有所对应，frame 设置之后一定要保证距离大于 distance 的设置。一般来说 distance 是不会触发，但是如果快速旋转的话有可能导致位置不变123456789101112131415161718192021222324252627282930313233343536373839404142434445464748tick() &#123; var me = this; if (me.data.ishead) &#123; me.DeduplicationStore(); return; &#125; if (me.system.position_recording[me._id - 1].length &gt; me.data.frame) &#123; var target_position = me.system.position_recording[me._id - 1][me.data.frame], last_current_position = me.system.position_recording[me._id - 1][0], target_rotation = me.system.rotation_recording[me._id - 1][me.data.frame]; if (me.Distance(last_current_position, target_position)) &#123; me.el.setAttribute('position', target_position); me.el.setAttribute('rotation', target_rotation); me.DeduplicationStore(); &#125; &#125;&#125;,Distance(target, current) &#123; var flag = false, result = 0; result = Math.sqrt(Math.pow((target.x - current.x), 2) + Math.pow((target.y - current.y), 2) + Math.pow((target.z - current.z), 2)); if (result &gt; this.data.distance) flag = true; return flag; &#125;, //去掉重复的位置后存储移动轨迹 DeduplicationStore() &#123; var me = this, current_position = &#123;&#125;, current_rotation = &#123;&#125;, last_position = &#123;&#125;, is_equel; me.Copy(me.el.getAttribute('position'), current_position); me.Copy(me.el.getAttribute('rotation'), current_rotation); me.Copy(me.system.position_recording[me._id][0], last_position); is_equel = me.Equel(last_position, current_position); if (!is_equel) &#123; me.system.position_recording[me._id].unshift(current_position); me.system.rotation_recording[me._id].unshift(current_rotation); &#125; if (me.system.position_recording[me._id].length &gt; me.data.frame + 1) &#123; me.system.position_recording[me._id].pop(); &#125; &#125;, 总结这个组件写的时候不是很清楚，出了很多错，数据存储的时候出了顺序问题，跟随的时候距离设置出了问题，初始化距离出问题。。。花了很多时间调这个。 这个就是最主要的组件，其他还有 food，eat 组件，foot设置食物的属性，加速度或者体型 eat 绑定碰撞检测，碰撞后销毁 food 对应的 dom，并添加对应属性]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[贪吃蛇(一)]]></title>
    <url>%2F2017%2F10%2F26%2F%E5%B0%BA%E5%B7%A5%2F%E8%B4%AA%E5%90%83%E8%9B%87(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[前言一个 3d 的贪吃蛇。。 想法最开始的时候是想做一个多人对战的贪吃蛇游戏，可以吃小方块（可以变大，加速等），然后吃到别的蛇会把别人咬断，时限过后分最高的人获胜。 网络同步然后就开始偏离了原方向，游戏本体一点都没做而先去想多人实时对战的问题，最开始是打算能否直接用 IM 来发送相关消息进行实时通讯。用了网易云的通讯，小量的话免费而且文档还可以，比起辣鸡融云要好很多。不过接着往下了解的时候发现用 IM 去做的话不现实，因为没有服务端的判断，而客户端的信息都是不可信的，所以舍弃了 IM 的想法，相关资料如下 ow的网络同步关键术语： 帧同步关键问题： 发生丢包或延迟情况下依然能显示正确的逻辑我的理解是在客户端有两套逻辑，一套预测的和一套实际显示的，当你按下移动键时，客户端脚本会预测你的移动，并形成一个系列帧（正在向前走），并发送给服务端，服务端这时候同意判断，比如你是否被打死了，如果打死了则是不能移动的，再传回客户端，客户端这个时候纠正之前的预测并显示到画面上。在这个过程中如果网络不好，即没有及时的收到服务端的纠正，那么客户端就会沿用向前走的预测，并在收到服务端的纠正后再回退到预测时的那一帧，这就是玩游戏网卡时经常能看到的人物都自动在走，过了一会突然发生位移或者死人。 看到这的时候突然发现自己好像偏太远了。。游戏本体都没有，至少应该先做个单机版的再说，于是就把这个放着了。 3d 框架这之后开始想游戏实现，这之前有看了一点 A-FRAME 的相关使用，所以想着能不能用 A-FRAME 来实现，毕竟 THREE.JS 比较麻烦，需要去控制的东西很多。但是使用的时候还是发现有很多问题。A-FRAME 的自由度肯定是没有 A-FRAME 多，如果想实现一些和官方不太一样的组件就都得自己去写。中间犹豫几次到底用哪个，最后还是选了 A-FRAME，又好好的去看了看文档，然后开始写。 A-FRAME 使用A-FRAME 内置很多组件，每个组件里面又有很多的控制参数，所以推荐直接去看 NPM 下的 A-FRAME 包，src 文件夹下的对应文件，写的很清楚。每个组件都有开启和关闭，enable。基本元件是 &lt;a-entity&gt; 不过它有很多封装了的元件 &lt;a-box&gt; &lt;a-camera&gt; 等，这些元件都有默认绑上去的其他组件，比如position look-controls wasd-control 等。 一些认为比较实用的设置&lt;a-scene&gt; 的 embedded 设置 false 之后&lt;a-scene&gt;就不是全屏而是外层 div 的大小 &lt;a-camera&gt;的 wasd-controls 设置fly:true之后就可以全方位移动，而不是只能水平移动 另外官方有推荐很多其他的插件，和 vue-awesome 一样，有个 awesome-aframe,里面有很多相关的组件有2个组件觉得比较好，一个是动画组件aframe-animation-component,另一个是物理引擎组件aframe-physics-system基本上这个官方的综合库里面就够用了A-Frame Extras 用 physics 的时候还遇到个坑。。按照官网给的检测碰撞的事件写了之后并不触发，找了好久没找到，也提了 issues，本来都快放弃了，，最后找到问题是版本太低，，作者刚好在这几天修复检测碰撞的这个事件调用。。。 逻辑准备工作差不多到这里就完了，然后开始是实际编写时候遇到的一些问题首先因为自带的 wasd-controls 不能达到贪吃蛇的移动方式，于是就照着它写了一个 walk 组件，没有改多少，只是在 tick 中增加了 z 坐标的移动。写的时候发现官方组件的写法很厉害。。比如下面这个1234567891011121314151617181920212223242526272829303132333435var KEYS = [ 'KeyW', 'KeyA', 'KeyS', 'KeyD', 'ArrowUp', 'ArrowLeft', 'ArrowRight', 'ArrowDown'];&#123; init()&#123; this.onKeyDown = bind(this.onKeyDown, this); &#125; onKeyDown(event) &#123; var code = event.code; if (KEYS.indexOf(code) !== -1) &#123; this.keys[code] = true; &#125; &#125;, play() &#123; this.attachKeyEventListeners(); &#125;, pause() &#123; this.keys = &#123;&#125;; this.removeKeyEventListeners(); &#125;, remove() &#123; this.removeKeyEventListeners(); &#125;, attachKeyEventListeners() &#123; window.addEventListener('keydown', this.onKeyDown); &#125;, removeKeyEventListeners() &#123; window.removeEventListener('keydown', this.onKeyDown); &#125;,&#125; 首先是按键的绑定，这种对应的方法觉得很巧妙123if (KEYS.indexOf(code) !== -1) &#123; this.keys[code] = true;&#125; 首先是利用数组查找对应按键，再给keys对象添加一个对应属性。 另外还有一个很厉害的绑定事件方法，一下是源码123456789101112131415/** * Faster version of Function.prototype.bind * @param &#123;Function&#125; fn - Function to wrap. * @param &#123;Object&#125; ctx - What to bind as context. * @param &#123;...*&#125; arguments - Arguments to pass through. */module.exports = function bind (fn, ctx/* , arg1, arg2 */) &#123; return (function (prependedArgs) &#123; return function bound () &#123; // Concat the bound function arguments with those passed to original bind var args = prependedArgs.concat(Array.prototype.slice.call(arguments, 0)); return fn.apply(ctx, args); &#125;; &#125;)(Array.prototype.slice.call(arguments, 2));&#125;; 它将原来绑给 window 对象的方法给转到了绑了该组件的 dom 上。不过这段代码其实没怎么看懂。。以及另外一个需要注意的，在复杂结构运算时需要对对象进行copy，不然很容易修改赋值会改变原来对象而出现很多想不到的问题。移动需要注意的两点 使用向量去进行移动运算，方便进行同时按下多方向的判断 全局坐标系和当前坐标系的转换 没写完的留下一次吧。。感觉好多]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编辑器]]></title>
    <url>%2F2017%2F10%2F11%2F%E5%B0%BA%E5%B7%A5%2F%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言最近一直在折腾编辑器，以前用的是 adobe 的 brackets，这个编辑器其实个人觉得还可以，风格设计好看，但是还是有些缺点，比如打开时间慢，打开混编的代码或者大文件很卡，安装扩展的时候很容易网络不好而安装不成功，不过也是可以自己去 github 上下了对应包放在对应文件夹下。 于是去了解了下其他的主流编辑器， sublime atom vscode 这些。现在已经投入到 vscode 的怀抱 sublime名气超大。。现在已经是 sublime3，本身很小。功能基本都需要自己下载插件，有些麻烦。时不时会有个弹窗为你是否购买 license，比较烦。 atom这个只是去了解了下，并没有下来看看，一个是下载速度慢，另一个是感觉很大。另外大家好像都吐槽用这个打开大文件卡 vscode最开始记得有人提起过，不过没有在意，这次找编辑器的时候才重新注意到，微软出品，开源。质量上有了保障，同时自身带有很多功能，不需要向 sublime 那样什么都需要自己下。断点调试，终端，emmet，内置git，侧边栏功能等等，基本有了这个编辑器就不需要再打开文件夹。而且他的插件虽然没有 sublime 多，但是都很好用，配置也不麻烦。同时自带很多快捷键很方便。 微软大法好！ vetur用 vsc 写 vue 的时候会装一个插件 vetur，但是这个 vetur 插件的代码格式优化和其他的不一样。这个插件本身集成了 emmet prettier 等其他插件，并进行了单独设置，所以它的有些方面就比较烦人，比如它默认是双引号，全加分号，所以想自定义的话需要单独设置。1234"vetur.format.styleInitialIndent": true, // style 标签缩进"vetur.format.scriptInitialIndent": true,// script 标签缩进"vetur.format.defaultFormatter.js": "vscode-typescript", "vetur.format.defaultFormatter.html": "js-beautify-html" js 格式化有三种可选prettier,vscode-typescript,nonehtml 只有两种 none,’js-beautify-html’而且对于 html 的格式化觉得也不算很好，缩进是对的，但是回车换行就很不友好 为啥没有 css？，因为css只有’none’,’prettier’默认就是prettier，将就用吧 至于 vetur 的缩进，觉得它的设置比较迷。。最开始版本是受 prettier 的 tabWiths 和 useTab 选项影响【应该是叫这个名字。。】可以通过更改编辑器或者添加 prettierrc 配置文件来进行更改，之后跟新了是根据编辑器的 tabSize 来设置，但是这里有一个问题，当开启 detectIndentation 之后，它的选择就会出问题。。所以如果要设置 vetur 的缩进为4的话，需要把这个关闭。另外 vetur 的格式化不受 editorconfig 影响。 其他vsc 支持 .editorconfig 文件，自]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据响应]]></title>
    <url>%2F2017%2F09%2F29%2F%E5%B0%BA%E5%B7%A5%2F%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[前言前端所做的事情主要就是 处理数据 展示数据 发送数据 数据相应view = render(state)是一句很经典的话。不过一般页面渲染只发生在页面开始加载时或者有事件驱动的时候。而很多需求要求的是动态的更改数据并展示。 脏检查 pull重新拉数据对比 传统的方法是将页面中有绑定数据的节点的虚拟 dom 树和由跟新某个数据产生的新 dom 树全部检测比对后再重新渲染，俗称脏检查。脏检查也有一些优化的方法，比如跳过这个 dom 树中未绑定数据的子树，跳过数据没有变化的子树等。 vue fetch push有更改的主动推上去更改 1234&lt;div v-for="item in data" id="box"&gt; &lt;div id="box1"&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt; &lt;div id="box2"&gt;&#123;&#123;itme.no&#125;&#125;&lt;/div&gt; &lt;/div&gt; 具体流程拿 vue 的 v-for 来举例子，v-for 的流程其实是先创建一个 dom 树【以使用 v-for 的 dom#box 为根节点】，然后再将这个 dom 渲染到真实的 html dom 树中。如果 item.name 数据有更改，则触发相对应的 getter/setter 更改旧的虚拟 dom 树中的 #box1 节点，再将此虚拟树和 html 中树相替换。以此达到数据响应。 双向绑定其实一样，事件驱动改数据，数据再由上面的渲染后改动页面 但是，这种方法会给所有需要的数据全部加上 getter/setter 来 watch ，比较耗性能。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[手机网页支付]]></title>
    <url>%2F2017%2F09%2F26%2Fnew%2F%E6%89%8B%E6%9C%BA%E7%BD%91%E9%A1%B5%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[前言最近做手机网页支付，就微信，支付宝，qq钱包三种支付，把其中踩的坑总结一下。 大概原理后台向支付平台提交订单获取参数。通过 js 跳转 app 的带参 url schema ，唤起 app 进行支付。支付后跳到商品详情页面，查询是否支付成功并显示相应信息。 准备工作这三种都需要去官方的公众平台去开通相应功能，并设置授权域名qq 钱包支付使用场景默认在 qq 或 tim 内使用，一般配合 qq 公众号。公众号这个和商户没有关系，只需要将支付网页的链接放到二级域名就可以。 技术文档如下支付宝微信支付qq钱包 开发流程 支付宝场景：非微信浏览器网页中，辣鸡微信支付宝做的是最好的一个，无论是文档还是使用流程。该有的都有，实乃业界楷模。各种支付模式，应用场景支付宝有额外的沙盒模式，它会为每一个注册的应用分配一个单独的支付宝沙盒版app，付钱可以随意更改。 支付宝的流程也很清楚，商户页点支付，商户后台向支付宝下单并从支付宝那边获得并返回商户页一个 url ，商户页通过 url 跳转到支付宝自己的支付网页，该页面的逻辑是跳转过来后就尝试通过 url schema 去唤起支付宝，同时进行一个 setTimeout 5s，若唤起支付宝，该网页就不需要处理，没唤起支付吧，则会自动出现继续支付和已完成支付两个按钮，点击继续支付会出现网页登录支付宝，然后进行支付的流程，点击完成支付则会弹出提示。当支付完成后，支付宝会自动跳转到商户后台指定页面，商户后台可以配置一个指定的支付后商品详情页面的 url ，用来显示商品支付详情。商品详情的数据需要两个判断，因为是异步的通知，首先判断商户自己的游戏币有没有到账【通过处理支付宝那边的异步通知进行的游戏币增加】，如果没有到账【由于网络原因此时异步通知还未发送】就主动去查询支付宝商户此订单的详情。且商户后台此时可以增加一个查询日志，这样也方便以后出现充值失败的时候寻找原因 如果是在 app 的 webview 中的话，需要对 webview 进行设置 微信场景：非微信浏览器中，微信浏览器中用公众号支付，使用 sdk，辣鸡微信辣鸡微信的文档很烂，好像最近一年才开通 wap 支付，即非微信浏览器的网页支付。辣鸡微信基本没有做流程判断，且很多逻辑没有去做。虽然有同步跳转，但是得自己构造 url 的参数 redirect_url，且无论用户支付成功或失败都会跳转过来，辣鸡。另外辣鸡微信没有考虑未安装微信的情况，还是会去尝试打开，只不过没反应。然后5s之后就自动跳转到 redirect_url。这里为了去增加一个提示用户没有安装微信的功能，尝试去用 iframe 去做，代码如下12345678var node = document.createElement("iframe"); node.style.display = "none"; node.src = url document.body.appendChild(node); setTimeout(() =&gt; &#123; me.set_error('未安装微信客户端') document.body.removeChild(node) &#125;, 5000) 用 iframe 的目的其实就是要即能打开给定的url，又要保持自己对页面的控制器【在自己的页面】，逻辑也很简单，因为目标微信页面会自己去唤醒微信客户端 weixin:// ，【这段代码藏在这个微信页面里，拿不出来，只能用它给定的页面】，下面为了简洁直接把这个页面当作唤醒。5s 内如果唤醒了就直接去客户端那边了，网页这边也不用处理了，5s 还未唤醒那么就默认没有装微信。 这个方法虽然可用，但是5s 的等待时间还是太长了，用户交互的话得加个 loading 图，且由于网络原因无法保证 5s 是个准确的时间，另外无法显示 redirect_url，因为这个页面是在 iframe 中打开的。默认也会在 iframe 中显示，如果这个时候 iframe 节点被删掉，那么这个回调页面就显示不出来。所以最后还是没有用这种方法，没有增加给用户提示未安装客户端的提示，转而在商品详情页面给出支付失败原因的提示。 url schema在这里顺带提一下这个东西，一般 app 安装的时候都会去在手机上设置一个协议【前提是写 app 的时候有设置这个，不过一般都有设置，设置也很简单】如 myapp:// 这个协议，然后通过自己配置参数，实现很多功能，很多 js_bridge 也是通过这个原理来实现 js 和 app 的通信。 js 可以通过打开这种 url ，然后会被系统检测到并打开相应的 app。【不能通过浏览器方式输入打开】一般都是通过 iframe 或者 a 标签来打开。如果有安装，就会直接打开。很多 sdk 其实就是封装了这些 url schema，做了一些判断处理的库，比如下面要说的 qq 支付的sdk。 qq钱包这个是只能在 qq 浏览器中，更明确点是在 qq 内的公众号内使用，以前都不知道 qq 还有公众号来着。。具体流程和微信公众号差不多，并且因为场景的限制，使用情况也不需要考虑那么多。既然在公众号内，那么肯定能调起支付。具体使用就调 qq 提供的 sdk 接口就好，qq 文档写的还是没支付宝好。具体使用，信息可以通过后端下订单后返回，pub 的那2个是关于公众号的是否关注和提示语。且通过回调函数自己跳到目标网页。123456789101112mqq.tenpay.pay(&#123; tokenId: extras.tokenId, pubAcc: extras.pubAcc, pubAccHint: extras.pubAccHint, appInfo: "appid#" + extras.appId + "|bargainor_id#" + extras.bargainorId + "|channel#wallet"&#125;, function(result, resultCode) &#123; if (!resultCode) &#123; location.href = '商品详情页' &#125; else &#123; me.set_error('支付失败'); &#125;&#125;) 后端逻辑通过开通对应支付服务后会给分配一个 id，然后自己配置签名，密钥等，主要就是下单，查单，处理异步通知，打印日志。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[百度站长]]></title>
    <url>%2F2017%2F09%2F15%2F%E5%B0%BA%E5%B7%A5%2F%E7%99%BE%E5%BA%A6%E7%AB%99%E9%95%BF%2F</url>
    <content type="text"><![CDATA[前言该死的百度zz，以前提交多少次不成功，这次竟然。。 之前是因为 githubpages 服务对百度搜索一直屏蔽，所以博客的访问量很少。。。所以一直想让百度能收录这个站点但是之前搜索很多方法都很麻烦，如下 设置cdn 使用 coding.net(山寨版的github) 不过后来使用百度分析的时候偶然看到百度智障工具可以主动提交收录网站，所以就准备研究研究。但是在验证网站的过程中一直显示不成功。给跪了。。官方提供三种验证方式 文件验证 需要下载给定文件放在网站根目录下 html 标签验证 增加一个 meta 标签到首页 html CNAME 验证 设置 cdn 解析 最开始选的是第一种方式，因为感觉比较简单。。但是。试了无数次后发现根本不好用第二种又不太方便，因为使用的 hexo ，这些东西不太方便改然后我就放弃了，这次偶然再上来试了下第三种方式竟然成功了。。 我是使用的万网域名，点开 cdn 解析后直接添加一条就好 CNAME 百度站长给定域名 默认 zz.baidu.com 然后成功后再百度智障工具下面的搜索展现下面的官网保护下面提交，就可以进行收录了。。。目前还是审核状态，成功了再回来修改 过了快2周了，审核还没过。。 emmmmmm。。。14天了，还是没过，但是可以百度到了。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[A-FRAME(一)]]></title>
    <url>%2F2017%2F09%2F13%2Fnew%2FA-FRAME(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[前言接着上篇的 VR 介绍这个新出的库 概念嗯。。这个库已经明说了是对 three.js 的封装。而且既然还是 ECS 模式的看来和这个库还真是有缘。 在这个框架里面。代码依赖在 dom 上，通过对属性的重写来实现 3d 组件，如常规的场景，摄像机，灯光，实体等。这种绑在 dom 上的写法刚开始很不习惯。。什么都往 dom 上加，然后通过选择器选 dom 进行操作，setAttibute addeventlistener 来进行操作。另外因为之前都用 requestAniamtionFrame 来主动控制，添加场景实体等操作，所以对于这种非主动控制的有点无从下手。 不过熟悉之后发现，这种写法还是很好的。通过注册组件来自定义行为，将组件作为属性加到 dom 上使其自动渲染生效。 下面是一段简单的例子123456789101112131415161718192021222324&lt;a-box position="-1 0 -5" rotation="45 45 0" color="#4CC3D9" float="to: -1 0.5 -5;"&gt;&lt;/a-box&gt;AFRAME.registerComponent('float', &#123; schema: &#123; animation: &#123; type: 'string', default: "property: position; dir: alternate; dur: 2000;loop:true; easing: easeInOutSine;" &#125;, to: &#123; type: 'string', default: '0 0 0;' &#125; &#125;, init: function () &#123; var data = this.data; this.el.setAttribute('animation__float', data.animation + 'to:' + data.to); &#125;&#125;); position rotation color 这些是自带的一些组件。animation 则是一个三方的库，官方主动说建议放弃自己的 &lt;a-animation&gt; 标签而使用这个。。 A-FRAME 框架自动集成了很多东西，也有很多默认值。大多数还是挺方便，少部分找不到对应的 api 就很麻烦。而且由于它把所有的过程都封装了，所以对渲染的流程可能会有些不清楚。 方法1234567891011AFRAME.registerComponent('bar', &#123; schema: &#123; size: &#123;type: 'number', default: 5&#125; &#125; init()&#123;&#125;, update()&#123;&#125;, remove()&#123;&#125;, play()&#123;&#125;, pause()&#123;&#125;, tick()&#123;&#125;&#125; schema只是用来检测数据，和 mongoose 的 schema 差不多。type 有很多种，不过不支持对象类型，当传的数据类型不对时会报错。default 是默认值，如果不传值的时候默认按这个。 init初始化时调用一次 update初始化或属性更新的时候调用 remove属性被移除【通过 removeAttribute removeChild】 tick场景渲染的每一帧调用 基本都是字面意思。。不写了 其他 系统间依赖顺序 1234567AFRAME.registerComponent('a', &#123; dependencies: ['b']&#125;);// Initializes second.AFRAME.registerComponent('b', &#123; dependencies: ['c']&#125;); 多个实例 1234AFRAME.registerComponent('foo', &#123; multiple: true, // ...&#125;); 默认只能有一个实例，开启后可增加多个，如 float__1 float__2，可通过 id 判断区分 获取组件1var components = document.querySelector('[components_name]').components.components_name; 属性this.data获取 schema 中的数据 this.el获取绑定的 dom]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[反省]]></title>
    <url>%2F2017%2F09%2F10%2F%E5%8F%B9%E8%A8%80%2F%E5%8F%8D%E7%9C%81%2F</url>
    <content type="text"><![CDATA[这一个月以来一直无所事事，比树懒还懒，整天觉得空虚无聊没意思。在网上晃来晃去，完全没有意义的在浪费时间。能做的事情，要做的事情都很多，但是却什么事情都不想做。回来之后就玩手机，不过连手机上的游戏都不想去肝，就上线看一下，然后看微博，那么多关注竟然都能看完，而且看微博那些无意义的视频就像吃药一样根本停不下来。期间还养成了各种不好的习惯。 现在太放纵自己了，因为目前的自由而随心所欲，完全就是人间失格叶藏的早期。闲逛的时候还沉迷进了很多不好的东西，辛亏自己还能清醒的停止自己不要深入，还能想起一些美好的东西。不然陷进去了真是可怕。感谢过去的我把我从深渊里拉起来。 为什么自己这近一个月会变成这个样子，现在想想真是偏离了正路好远。做事不再认真，得过且过。房间不想收拾，乱糟糟的。明明决定的事情却自己一而再的给找理由而推迟或者不做。同时被自己的欲望给牵着走，理智完全不见。每天坚持的弹琴画画也都觉得没有意义。 整体喊着这没意思，那没意义的我真是没救了。明明早就知道所有的事情必须自己觉得有意思，自己去认真做才会让自己和他人满意。明明早就知道什么是该做的却觉得不想走固定的计划好的路而不去做，因为想遇见更好的人，更好的事而反向的去刻意交结，讨好别人。为了打发时间，填满空虚的内心而去说些无意义的话。我所期待的更好的人绝不是这个样子，虽然目前仍然不知道是否可以遇到，怎样做才可以。但是现在的这个样子即使遇到了别人也会绕道而走。我应该尽可能的使自己更好，走到更高的地方才会有更大的可能。 另一方面，我自己在人际交往上也有很大的问题。自己并不擅长和人相处，就像周国平说过的，和人相处时，既不想让自己显的有趣又不想和无聊的人共处，还是一个人静坐比较好。可我现在只达到了第一阶段，或许连第一阶段也没有。因为我并没有对对方的了解，所以并不知道对方是否无聊。这是一项需要时间的技术，可是现在的社会环境根本没有这些时间，而我又是死宅，大门不出，二门不迈。所以我并不能去知道对方，但是却自大的把周围的人都定义成无聊的人，其实我自己才是最无聊最垃圾的人。这样的我却还渴望着遇见知音，恐怕神都满足不了我。 其实仔细想想，我身边就有很多很好的人，他们在不同的方面都是值得我去学习的，人是有很多方面的，也是复杂的。我不能因为某一面而全盘否定。产生这种问题的原因是自己的内心还太软弱，不想吃苦却想一步登天，渴望回报却不想付出，有野心欲望却没有动力和执行力。太容易放弃，我是什么时候成了这样的人呢。 自己怕麻烦是很久以来就有，但是因为怕麻烦而不去做只能招惹更多的麻烦，奉太郎说过的，必要的事情尽快做，不必要的事情不做。那么怕麻烦的他都有如此的信条，自己确实应该改正。 另外我自己似乎也很希望有蔷薇色，希望有一段美好的回忆，啊不，记忆。这似乎和我口中一直说的没兴趣，没想法，不想交异性朋友相矛盾。可能我期待的只是次元的美好，而深知自己这样的宅心理变态是没可能，而且还有很多麻烦事情。比如现在社会事事都要让着，宠着对方。女性为尊一样。我虽然不讨厌这种，但是绝谈不上喜欢。我所喜欢的社会是明国，日本二战时期，中世纪欧洲这类的社会模式。虽然君子绅士在现在都变成了笑谈，不过我觉得那样很帅。在蔷薇色这一方我是失败者，迷途者，又是满怀憧憬，期待的祈祷者。既然不知道方法，像我之前那样的胡乱去找只能找到腐烂色。那么还是顺其自然吧。几於病态的这份心情还是安抚下来收好。 那么到现在，已经知道自己的原因是想有人交流和期待蔷薇色，这两者我唯一能做的是自己变的更好然后静静等待。这一个月的闹剧到此为止吧。我需要恢复自己觉得无聊，程序化的日常，慢慢的积累自己。好在来年有更好的选择。 现在我要做的是下列几项 做出自己认为好的游戏 提高自己的素养 加强自制力 坚持弹琴和画画 看书，电影和番剧我竟然忘记了第五条，我曾经赖以生存的一条。]]></content>
      <categories>
        <category>叹言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[悲秋的时候到了]]></title>
    <url>%2F2017%2F08%2F30%2F%E5%B0%BA%E5%B7%A5%2F%E6%82%B2%E7%A7%8B%E7%9A%84%E6%97%B6%E5%80%99%E5%88%B0%E4%BA%86%2F</url>
    <content type="text"><![CDATA[为赋新词强说愁]]></content>
      <categories>
        <category>叹言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分享]]></title>
    <url>%2F2017%2F08%2F25%2F%E5%B0%BA%E5%B7%A5%2F%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[分享哇，这个东西烦了我一天。 原理主要是用到 jsBridge 来实现网页和应用之间的通信。实现可以互相发状态 这个主要得看不同 app 内的实现，去找他们的 api。 微信微信页面分享比较麻烦。首先得有微信公众号，然后得到 appId,之后要在微信公众平台上设置受访域名。之后外链微信的 jsdk ，它会注册一个 window 下的全局对象 wx。然后这里需要服务端做一个逻辑，返回给你一些设置信息去初始化设置 wx.config()当 wx.config() 这个接口完成后会触发 wx.ready(cb)。然后执行回调 cb 这个自己写的方法。这时才能用微信的方法 qqqq浏览器比较简答，但是不知道有时候不生效是个什么鬼。。 代码12&lt;script src="http://open.mobile.qq.com/sdk/qqapi.js"&gt;&lt;/script&gt;&lt;script src="http://res.wx.qq.com/open/js/jweixin-1.2.0.js"&gt;&lt;/script&gt; share.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import vm from './main.js'var share = &#123; config: &#123; title: '', link: '', img: '', desc: '', appid: '', &#125;, init() &#123; vm.$http.post('http://test.mrpyq.com/api/weixin/jsapi_sign', &#123; url: location.href.split("#")[0] //不带hash，query &#125;).then( (res) =&gt; &#123; wx.config(&#123; debug: false, appId: share.config.appid, timestamp: res.body.timestamp, nonceStr: res.body.noncestr, signature: res.body.signature, jsApiList: ['onMenuShareTimeline', 'onMenuShareAppMessage', 'onMenuShareQQ', 'onMenuShareQZone'] //需要使用的微信方法 &#125;); this.wx(); &#125; ) this.qq(); &#125;, wx() &#123; if (window.wx) &#123; wx.ready(function () &#123; wx.onMenuShareTimeline(&#123; title: share.config.title, // 分享标题 link: share.config.link, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: share.config.img, // 分享图标 success: function () &#123; // 用户确认分享后执行的回调函数 &#125;, cancel: function () &#123; // 用户取消分享后执行的回调函数 &#125; &#125;); wx.onMenuShareAppMessage(&#123; title: share.config.title, // 分享标题 desc: share.config.desc, // 分享描述 link: share.config.link, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: share.config.img, // 分享图标 type: '', // 分享类型,music、video或link，不填默认为link dataUrl: '', // 如果type是music或video，则要提供数据链接，默认为空 success: function () &#123; // 用户确认分享后执行的回调函数 &#125;, cancel: function () &#123; // 用户取消分享后执行的回调函数 &#125; &#125;); wx.onMenuShareQQ(&#123; title: share.config.title, // 分享标题 desc: share.config.desc, // 分享描述 link: share.config.link, // 分享链接 imgUrl: share.config.img, // 分享图标 success: function () &#123; // 用户确认分享后执行的回调函数 &#125;, cancel: function () &#123; // 用户取消分享后执行的回调函数 &#125; &#125;); wx.onMenuShareQZone(&#123; title: share.config.title, // 分享标题 desc: share.config.desc, // 分享描述 link: share.config.link, // 分享链接 imgUrl: share.config.img, // 分享图标 success: function () &#123; // 用户确认分享后执行的回调函数 &#125;, cancel: function () &#123; // 用户取消分享后执行的回调函数 &#125; &#125;); &#125;) wx.error(function (res) &#123; &#125;); &#125; &#125;, qq() &#123; if (window.mqq) &#123; if (mqq.ui.setOnShareHandler) &#123; mqq.ui.setOnShareHandler(function (type) &#123; mqq.ui.shareMessage(&#123; title: share.config.title, desc: share.config.desc, share_type: type, share_url: window.OPEN_DATA.shareurlk, image_url: share.config.img, back: true &#125;, function (result) &#123; //result &#125;); &#125;); &#125; if (mqq.invoke) &#123; window.mqq.invoke("data", "setShareInfo", &#123; share_url: window.OPEN_DATA &amp;&amp; window.OPEN_DATA.shareurl, title: share.config.title, desc: share.config.desc, image_url: share.config.img, callback: function () &#123;&#125; &#125;); &#125; &#125; &#125;,&#125;export default share; 配置填下 config微信的话接口需要后台做些逻辑，比如生成签名另外 qq 说 meta 也有用，不过我试了下没用123&lt;meta itemprop="name" content="标题" /&gt;&lt;meta itemprop="image" content="图片地址" /&gt;&lt;meta name="description" itemprop="description" content="描述" /&gt;]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[活动页开发(三)]]></title>
    <url>%2F2017%2F08%2F24%2F%E5%B0%BA%E5%B7%A5%2F%E6%B4%BB%E5%8A%A8%E9%A1%B5%E5%BC%80%E5%8F%91(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[前言这次做了个类似视频播放的单身狗页面，虽然很心痛，不过还是很有意思的。 详细视频播放是先拍视频，然后把视频剪成帧图片，再拼接成长图。通过图片的定位来实现视频播放的效果。 1234567891011&lt;img id="current_frame" src="~assets/1.jpg" alt="" :style="&#123;right:left_css,width:width_css&#125;" @click.prevent&gt;play() &#123; var me = this; me.left_css = me.index * 100 + '%'; me.index++; if (me.index &gt;= me.photos_count) &#123; me.show = true; clearInterval(me.Interval) &#125; &#125;, width_css 写为1000%（有10张的话）然后通过定位实现 bug1uc浏览器默认有个辣鸡看图模式，只要点击到图上就会进入看图模式，需要给 img 阻止 click 的默认事件。 bug2本来想加声音的，不过声音的支持性太差。 ios 无法设置 currentTime = 0，表现为只响一次解决： 通过 new 多个 audio 设置 src 再 play(); 部分浏览器没有声音没找到解决办法。。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[VR]]></title>
    <url>%2F2017%2F08%2F17%2F%E5%B0%BA%E5%B7%A5%2FVR%2F</url>
    <content type="text"><![CDATA[前言最近有很多大大微博上玩起了全景图，VR漫画确实表现力很强啊。 A-FRAME这个东西是 mozilla 搞出来的 web VR，虽然VR已经出了好长时间，而且现在都没多少巨头在搞这个了，（期待索尼）。出现的能实用的 vr 也少，好玩的 vr 游戏也少。玩时间长了还头疼。 不过这个工具还是挺有意思的，以前看到过没怎么细看。觉得很高大上就没管了。现在回来看其实也并没那么高大上。感觉其内部还是用了 three.js 。不过不知道能不能和 three.js 完美结合。然后将 js 的表现抽成特殊的 dom 节点。更具有结构性也更简单。（真是越来越傻瓜，three.js 封装 webgl，A-FRAME 封装 three.js）。用这个玩意做 VR 全景就一步操作。。。 demo 后话emmm，有时间了再仔细看看，说不定能把以前做的那个烂到不想碰的游戏改一改。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[跨域]]></title>
    <url>%2F2017%2F08%2F15%2Fnew%2F%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[前言最近写服务端的接口时，遇到了很多新的东西。比如本来很熟悉的跨域 跨域这个玩意基本上都是众所周知的东西，不在一个主机下，不在一个目录下的互相 xmlhttprequest 请求都算是跨域。并且不被允许（script 标签不算），主要为了防止一些恶意脚本但是这导致网页开发很麻烦，不过后又有另外一个标准叫做 cors, 它允许请求进行跨域。目前浏览器支持良好。 跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。以上来自 mdn， 所以主要分两种请求 简单请求不会触发 CORS 预检请求。 当使用下列方法之一GET HEAD POSTContent-Type ：//注:仅当POST方法的Content-Type值等于下列之一才算作简单请求text/plainmultipart/form-dataapplication/x-www-form-urlencoded 未设置下列集合外的首部字段Accept-LanguageContent-LanguageContent-Type （需要注意额外的限制）DPRDownlinkSave-DataViewport-WidthWidth12345678910111213141516171819202122GET /resources/public-data/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveReferer: http://foo.example/examples/access-control/simpleXSInvocation.htmlOrigin: http://foo.exampleHTTP/1.1 200 OKDate: Mon, 01 Dec 2008 00:23:53 GMTServer: Apache/2.0.61 Access-Control-Allow-Origin: *Keep-Alive: timeout=2, max=100Connection: Keep-AliveTransfer-Encoding: chunkedContent-Type: application/xml[XML Data] 复杂请求 使用了下面任一 HTTP 方法PUTDELETECONNECTOPTIONSTRACEPATCH 设置下列集合外的首部字段AcceptAccept-LanguageContent-LanguageContent-Type (but note the additional requirements below)DPRDownlinkSave-DataViewport-WidthWidth Content-Type 的值不属于下列之一:application/x-www-form-urlencodedmultipart/form-datatext/plain 复杂请求会先发送一个 options 请求1234567891011121314151617181920212223242526OPTIONS /resources/post-here/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveOrigin: http://foo.exampleAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: X-PINGOTHER, Content-TypeHTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://foo.exampleAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHER, Content-TypeAccess-Control-Max-Age: 86400Vary: Accept-Encoding, OriginContent-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 预检查完成后发送 post 请求12345678910111213141516171819202122232425262728293031POST /resources/post-here/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveX-PINGOTHER: pingpongContent-Type: text/xml; charset=UTF-8Referer: http://foo.example/examples/preflightInvocation.htmlContent-Length: 55Origin: http://foo.examplePragma: no-cacheCache-Control: no-cache&lt;?xml version="1.0"?&gt;&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:40 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://foo.exampleVary: Accept-Encoding, OriginContent-Encoding: gzipContent-Length: 235Keep-Alive: timeout=2, max=99Connection: Keep-AliveContent-Type: text/plain[Some GZIP'd payload] 服务端配置其实主要就是客户端这边的 Origin 头和服务端那边的 Access-Control-Allow-Origin 做的判断通常在实际生产过程中，服务器那边会做更仔细的判断，不过我自己写的是允许所有的 123456789101112app.all('*', function (req, res, next) &#123; res.header('Access-Control-Allow-Origin', '*'); res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild'); res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS'); if (req.method == 'OPTIONS') &#123; res.send(200); /让options请求快速返回/ &#125; else &#123; next(); &#125;&#125;);]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[body-parser]]></title>
    <url>%2F2017%2F08%2F15%2F%E5%B0%BA%E5%B7%A5%2Fbody-parser%2F</url>
    <content type="text"><![CDATA[前言在从 vue-resource 转到 axios 的时候设置 application/form 格式的时候遇到了一些问题。 axiosemmm,现在这玩意突然火起来就因为作者尤大的一句话，大意就是考虑到 vue 的生态组件，觉得没必要把 vue-resource 这个东西放进来，所以就决定不再去维护这玩意，然后建议大家去用axios。然后大家都去了。 vue-resource躲在旁边: 明明是我先的。。。 不过 axios 确实要强大点，毕竟支持 node 环境和浏览器环境发请求，虽然还有一些其他功能，不过感觉都没啥用.axios 的用法和 vue-resource 用法一样。12axios.get('url',&#123;params:&#123;&#125;&#125;).then()axios.post('rl',&#123;&#125;).then() 然后都可以设置 baseurl。12345var instance = axios.create(&#123; baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: &#123;'X-Custom-Header': 'foobar'&#125;&#125;); timeout 这个是指明在这个时间内还没返回这个请求就会被中止 使用问题在使用 axios 的时候，它默认发的请求是 application/json 格式，而服务器识别的是 application/x-www-form-urlencoded，如果服务器没有特殊处理是取不到 req.body所以这里就有两种策略，一种服务端做处理，一种客户端做处理。 客户端客户端操作，官方给出了几种方法，下面是我觉得比较好点的 browser12var qs = require('qs');axios.post('/foo', qs.stringify(&#123; 'bar': 123 &#125;)); 依赖 qs 库 node12var querystring = require('querystring');axios.post('http://something.com/', querystring.stringify(&#123; foo: 'bar' &#125;)); 使用自有的模块 服务端使用 body-parser 中间件它是把服务端不识别的 application/json 转换成类 json 格式，然后再通过 JSON.stringfy() 转成 JSON 格式。最后再JSON.parse()转成对象。。比较绕。。 将不正确的json格式 {mail:’b’, password: ‘bb’} 装转为正式的json格式 {“mail”: “b”, password: “bb”} 12345678910111213141516var express = require('express')var bodyParser = require('body-parser')var app = express()// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded(&#123; extended: false &#125;))// parse application/jsonapp.use(bodyParser.json())app.use(function (req, res) &#123; res.setHeader('Content-Type', 'text/plain') res.write('you posted:\n') res.end(JSON.stringify(req.body, null, 2))&#125;) emmm,官方给的用法，注意下面的那个请求， body-parser 只是帮你转成了类 json 格式，还需要自己再去转。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ECS]]></title>
    <url>%2F2017%2F08%2F07%2F%E5%B0%BA%E5%B7%A5%2FECS%2F</url>
    <content type="text"><![CDATA[ECS这是一种设计模式，主要用于游戏中 Entity Component System Entity实体这是一个物体，相当于一个人物由多个 Component 组成 Component数据这是一个部件，相当于手臂之类 System行为这是一个动作，相当于行走操作多个 Component ecs 的一个核心点就是组件无函数，系统无状态，充分解耦这个模式的好处是更方便添加修改，比传统的 oop 更简单比如一个勇者，一个怪物，oop 的话得去在勇者对象中写勇者受到这个怪物的技能会造成什么影响，如果再增加一个新怪物，又得回去修改勇者对象ecs 的话就直接增加一个 system（另一种新技能），然后根据碰撞组件修改勇者的 component 就好]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[服务器部署nuxt]]></title>
    <url>%2F2017%2F07%2F20%2Fnew%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2nuxt%2F</url>
    <content type="text"><![CDATA[前言nuxt.js 是一个基于 vue.js 的服务端渲染应用框架（集成了 vue webpack babel），主要注重于 ui 渲染，可生成静态站点，框架灵活。 安装vue init nuxt/express &lt;project-name&gt;对 express 比较熟悉，所以装这个模板文档 nuxt 结构nuxt 采用 vue webpack 等来构建渲染。基本结构如下 .nuxt +assets +build +dist +components +layouts +pages +plugins +server +static +store nuxt.config.js assets: 资源文件static: 静态文件，不参与编译，和 express 中的 public 是一样的，可以将网页资源 dist/index.html 放入其中然后直接访问 host/distbuild: npm run build 后生成编译后 node 执行文件dist: npm run generate 后生成的静态站点，可放 githubpages 上layouts: 和 express 中的 view 相同，为模板文件componnts: vue组件pages: 服务端渲染的主要 vue 文件，内置 vue-router 根据 pages 目录结构生成路由store: vuex,可通过传统的 vuex 配置或者和 pages 一样的，新建很多文件然后自动配置为 models，具体看文档plugins: 插件server: 服务器功能，接口等，在这里面接上 mongodb 进行接口处理。nuxt.config.js: 配置文件，可自己扩展 webpack 等。 nuxt 中有很多不同的概念 因为为组件渲染过去，所以是没有一般的 html head 标签中的内容的，所以引入了 vue-meta （好像是叫这个名字）,然后在组件 script 中有一个 head(){} 方法，可以设置 head 头 渲染涉及到数据，所以多出一个 asyncData(){} 和普通的 data 区别就是会一直等待数据获取到后再装填。配合 await 还挺好用的。 nuxt 其实和 express 比就多了个服务端渲染页面的功能，而且和 vue 的用法很像，上手也比较容易 server 文件夹下其实就是 express ，在其中写接口也挺方便的，在将 mongoose 引进来。route 在 nuxt 中有默认生成，按照文件的位置。当然也可以自己定义 目前所知bug 使用 pm2 进行管理的时候，pm2 的自启动对其好像无效 在手机端部分浏览器（uc）出现很多问题，如@click事件失效，无法引入文件等等虽然提了 issuse ，但是得到的返回是等待下一次的更新和加上 babel-polyfill 配置。123456789build: &#123; extend(config, &#123; isClient &#125;) &#123; if (isClient) &#123; config.entry.vendor.unshift('babel-polyfill'); &#125; &#125;&#125; 跟新最近 nuxt 跟新的很快，不过一直都是 rc 版本，什么时候发了 1.0 再研究研究]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[虚幻寒霜]]></title>
    <url>%2F2017%2F07%2F17%2F%E5%B0%BA%E5%B7%A5%2F%E8%99%9A%E5%B9%BB%E5%AF%92%E9%9C%9C%2F</url>
    <content type="text"><![CDATA[fantastic！寒霜3 Frostbite3虚幻4 Unreal4 上面这两一听就 hi 爆了。而且做为游戏引擎渲染效果确实也是很棒。寒霜3的天气光影很棒，能给人一种很舒服的感觉，且所有物体都可破坏虚幻4是开源的！开源的！开源的！！，在 github 上可以 fork ，不过这是个私人项目，你得先注册 epic 然后 绑 github，之后接到项目邀请就可以看到了。 unity 3d这个烂大街，还收费，不过上手快，资源多。 虚幻4开发语言为 c++, 这点不友好。。。开发编辑器比较好用。支持中文，可选蓝图模式或者编程模式.下面是官方带的几个例子中的一个（第一人称射击）效果大赞啊。不过游戏开发涉及到的东西太多，目前也就只能玩玩例子了。]]></content>
      <categories>
        <category>杂乱</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[活动页开发(二)]]></title>
    <url>%2F2017%2F07%2F10%2F%E5%B0%BA%E5%B7%A5%2F%E6%B4%BB%E5%8A%A8%E9%A1%B5%E5%BC%80%E5%8F%91(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[前言老是想不起来做这个总结。。。 emmmmm 文字换行服务器返回的 json 转换后回车和空格会发生变化，放在 textarea 中没有问题，但是放在 div 中的话回车和换行就会不显示。这个时候就得加上一行 css 样式来解决这个问题1white-space: pre-wrap; 以下来自 mdnwhite-space CSS 属性是用来设置如何处理元素中的空白。值 normal连续的空白符会被合并，换行符会被当作空白符来处理。填充line盒子时，必要的话会换行。 nowrap和 normal 一样，连续的空白符会被合并。但文本内的换行无效。 pre连续的空白符会被保留。在遇到换行符或者’br’元素时才会换行。 pre-wrap连续的空白符会被保留。在遇到换行符或者’br’元素，或者需要为了填充line盒子时才会换行。 pre-line连续的空白符会被合并。在遇到换行符或者’br’元素，或者需要为了填充line盒子时会换行。下面的表格总结了各种 white-sapce 值的行为： 表现 换行符 空格和制表符 文字转行normal 合并 合并 转行nowrap 合并 合并 不转行pre 保留 保留 不转行pre-wrap 保留 保留 转行pre-line 保留 合并 转行 然后这里也提一下其他几个属性 字间距，字符间距12word-spacingletter-spacing 换行12word-breakword-wrap 上面的是所有都换行下面则是显示整个单词，例如一个单词过长，会把它单独提到下一行word-wrap 兼容竟然更好?! 文字两行显示12345overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2; 锚点锚点的使用一般有两种方法，div 的 id 或者 a 标签的 name，长的就像。。。#top 和 dom 的 id 一样的a 标签可点击跳转 &lt;a href=&quot;&quot; name=&quot;#22&quot;&gt;33&lt;/a&gt;这样在页面后加 #id 后可以直接定位到指定 dom但是这种定位一般只限于第一次打开这个页面，定位之后再进行刷新是无效的。因为页面有个默认行为是会记录你上次在网页中的滚动位置，比如文章看一半跳到别的网页在回来会继续定位到这个地方。所以刷新或者前进后退都是不好使的。这时如果还想用的话就得自己去改 location.hash = &quot;#bottom&quot;js 方法有 dom.scrollToView(bool) 来定位到指定元素 locationlocation 一个对象，也可当一个字符串进行操作 location = urllocation.search 查询参数location.hash hash用的多的就这 2 个，可以通过它传数据然后页面解析 7牛图片7牛图片开启样式图片瘦身后对大图片的压缩效果很好。访问 png-center 方法取 url 参数123456function GetQueryString(name) &#123; var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)"); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;&#125; 取 cookie12345678get_access_token(cookie) &#123; for (let a = document.cookie.split(';'), i = 0; i &lt; a.length; i++) &#123; if (a[i].match(/cookie/i)) &#123; this.cookie = a[i].split('=')[1]; return; &#125; &#125;&#125;, 平滑定位123456789go_somewhere(rate) &#123; var speed = document.body.clientHeight / rate, interval = setInterval(() =&gt; &#123; var old = document.body.scrollTop; document.body.scrollTop += speed; if (document.body.scrollTop &lt;= old) clearInterval(interval); &#125;, 16)&#125;, 以前的方法,easeOut 可以换成别的函数123456789101112function easeOut(t, b, c, d) &#123; return -c * (t /= d) * (t - 2) + b;&#125;var timer = setInterval(function() &#123; //linear滑动定位 if (flag &lt;= t) &#123; ele.scrollTop = easeOut(flag, currentST, 0 - currentST, t) flag++; &#125; else &#123; clearInterval(timer); &#125;&#125;, 16);]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[blue_bird]]></title>
    <url>%2F2017%2F06%2F14%2F%E5%8F%B9%E8%A8%80%2Fblue-bird%2F</url>
    <content type="text"><![CDATA[幸福的青鸟小王子有一天突然想出发寻找幸福。因为国内最伟大的巫师告诉他：「幸福是一只青色的鸟，有着世界上最美妙清脆的歌喉，找到了之后得马上把它关进黄金做成的笼子里，这样，你就可以得到你想要的幸福。 他不顾国王及王后的哀求及挽留，只带了一个黄金笼子就踏上找寻幸福之路。小王子是英勇的，一路上虽有高山峻岭阻挡，但是他都不以为惧，只因为心中的那股执着在支撑着他。他经过了许多国度，得到了很多以前从没看过、从没听闻的知识，成了一个见闻广博的人。 小王子抓过不少青色的鸟，但是总在放进黄金鸟笼后，鸟便不知为何的死去。他知道，那不是他所要寻的幸福。 后来，黄金笼显得有些旧了，小王子也不再年轻。他突然强烈地忆起远方的双亲。小王子回到了自己的王国，才发现人事已非。国王和王后早在他离去后没多久，就因为过度的悲伤及思念而相继过世。由于没有继承人，所以这个王国的人民为了享有庇护，渐渐的搬离到邻国，现在的城镇只剩下几户人家。 小王子落寞的走在荒凉的街头，忽然有一个人拉住了他的衣角，盯着他怀里的黄金笼子。那是一个发鬓斑白的老人。 「大巫师！」小王子认出了他，失声叫出。 「王子，我对不起你，当初不应该鼓励你去找寻青鸟。」老人哽咽地说着，从破旧的口袋里掏出了一件物品。「这是国王及王后临终前要我交给你的东西，希望你好好珍藏。」说完，老巫师便摇着头，哀伤的离开了。 小王子一看，原来那是国王为幼时的自己雕的一只黄莺。刹那间，所有的回忆不断地出现，悲伤的眼泪涌出小王子的眼，他把木鸟紧紧的抱在胸前，十分地懊悔。突然，怀里的木鸟动了动，叫出了声音，小王子一呆，一不注意，就让黄莺给飞走了。 那是幸福的青鸟，而他却来不及将它放进黄金笼]]></content>
      <categories>
        <category>叹言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mongodb(二)]]></title>
    <url>%2F2017%2F06%2F12%2Fnew%2Fmongodb(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[概述 nosql这是个和口号一样的玩意，和 sql 没啥关系，sql 只是一个查询语言，mysql 才是关系型数据库的一个代表。nosql 并非就没有 sql 查询，它也不代表非关系型数据库。非关系数据库在社交应用，聊天通讯等使用较多。 mongooseelegant mongodb object modeling for node.js这是官方的介绍，优雅。。 个人理解它是相当于对 mongodb 做了一个中间层，对数据进行处理。 使用 安装连接npm install mongoose在原来的 express 框架中做些修改。我采用的是如下结构根目录下新建文件夹 model 来建立 mongoose 结构1234567891011var mongoose = require('mongoose'), con = mongoose.createConnection('mongodb://localhost:27017/test'), UsersSchema = new mongoose.Schema(&#123; name: String &#125;, &#123; versionKey: false &#125;);var users = con.model('users', UsersSchema)module.exports = users 首先引入依赖之后连接数据库，本地 27017 端口下的 test 数据库这里使用的是 createConnection(),它和文档上使用的有区别。1mongoose.connect('mongodb://user:pass@localhost:port/database'); 文档中的是建立的是默认的数据库连接，之后建立 model 也是用的这个默认，1var Tank = mongoose.model('Tank', schema); 这样就可以连接多个数据库做不同处理 schema,model,documentsschema 我理解它为一个抽象的对数据定义的结构，它本身有可以定义许多方法。但本身并不能进行操作model 是从它这里继承下来，并与数据库绑定，相当于 collections，可进行操作从 model 中 new 出来的实体对象 documents 则相当于是每一条数据。 数据验证 1234567891011121314151617181920212223242526var mongoose = require('mongoose'), con = mongoose.createConnection('mongodb://10.10.1.3:27017/test'), UsersSchema = new mongoose.Schema(&#123; name: &#123; type: String, required: [true, 'name is required'], validate: &#123; validator: function (v) &#123; return typeof v == 'string' &#125;, message: 'name is not a string' &#125; &#125;, age: &#123; type: Number, required: [true, 'age is required'], max: 12, min:0 &#125; &#125;, &#123; versionKey: false //取消版本锁，否则每条数据都会有个 _v 字段 &#125;);var users = con.model('users', UsersSchema)module.exports = users 以上建立了一个简单的 users 集合。以上定义了一个具有简单验证的 schema，如果出错，会在 err.errors 中显示错误信息type: 确定参数为指定类型，不是则报错，【为string的时候会自动把其他类型进行转换】required: 此字段为必须validata: 自定义验证函数，当返回为 false 时报错，附带 message 字段 number类型特有min,max，可确定范围string类型特有 enum, match, maxlength, minlengthenum: 确定字符串为给定枚举中的match: 正则匹配 bug在 mongoose 中，你给 model 定的名字会自动给你转成复数形式，【什么坑爹玩意】。除非你显示声明123456789var schema = new Schema(&#123; name: String &#125;, &#123; collection: 'actor' &#125;);// orschema.set('collection', 'actor');// orvar M = mongoose.model('Actor', schema, 'Actor');]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mongodb(一)]]></title>
    <url>%2F2017%2F06%2F07%2Fnew%2Fmongodb(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[前言node+mongodb 后台框架直接用了 express 生成了一个，方便好用。由于是基于node的，文件引入用require。项目结构也比较简单。 servre +bin 脚本命令 +log 日志 +public 静态文件,访问public下的dist,localhost:3000/dist +routes 路由，接口 +views 模板视图，用 jade 编写，也可以改成 html。 -app.js 主控制文件 -package.json 如果要新增加接口就在路由里面多建立一个文件，然后 app.js 引用就好。这是个典型的 mvc 模式， mongodbwindows 下用 mongodb 打开比较麻烦，所以就写了个 .bat 方便打开12345@echo offc:cd \Program Files\MongoDB\Server\3.4\binmongod.exe --dbpath d:\mongo\dbpause 之后本机的 27017 端口就可以连接也可以写入全局变量然后运行 robomongo这是一个 mongodb 的可视化工具，挺方便的。 连接用 mongoskin 或者 mongoose 都可以，不过用 mongoose 的多很多连接端口号mongodb://localhost:27017/test之后直接返回就可以123router.get('/', function (req, res, next) &#123; res.send(something)&#125;); test为你的某一个数据库，之后就可以进行操作了。这里我用的是mongoose，这个再找一篇说这个。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux服务器部署node]]></title>
    <url>%2F2017%2F06%2F01%2Fnew%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2node%2F</url>
    <content type="text"><![CDATA[前言在活动项目中自己利用 node 搭建后台 工具PuTTY连接 windows 服务器的话直接在运行里面输入 msysc 进行远程连接就可以，但是 Linux 服务器是通过 ssh 来连接的，所以需要下这么一个工具去进行连接，下载后直接输入服务器 ip，进入后输入账号，密码就可以进到 Linux 的命令行。 WinSCP图形化文件传输系统，可以方便的将文件传到服务器上 配置服务器安装node打开 PuTTY，输入服务器 ip 后就看到命令行界面，输入账号和密码进入服务器。检查服务器多少位下载对应的 node 版本。下载之后利用 WinSCP 将下好的压缩包拖进去，然后执行以下代码1234567891011tar xvf node-v6.10.0-linux-x64.tar.xz //解压cd node-v6.10.0-linux-x64/bin设置软连接ls./node -v //输出版本号，表示在当前目录下可用ln -s /root/node-v6.10.0-linux-x64/bin/node /usr/local/bin/node 设置全局ln -s /root/node-v6.10.0-linux-x64/bin/npm /usr/local/bin/npmnode -v // 之后就可以在任意位置使用 坑：我自己之前自作聪明，下到本地后先解压后改了名字【想着好打一点】，把文件夹传了过去，可是./node -v根本就没用。。哎。因为覆盖过去的没有权限 配置 node 环境变量设置全局变量首先进入vim /etc/profile按 i 进入编辑模式，在文本的最下面输入以下语句123export NODE_HOME=/root/node-v6.10.0-linux-x64export PATH=$PATH:$NODE_HOME/binexport NODE_PATH=$NODE_HOME/lib/node_modules 按 esc 退出编辑模式，打 :wq 退出保存，输入 source/etc/profile使配置生效坑：之前不知道这个玩意，npm 装的全局包一直保没有报 not command，因为找不到装的路径位置。后来把环境变量加上去的时候【复制的网上的代码】错打了几个字符，然后就还是报错。导致折腾了一个小时。 启动项目项目目录下面启动 node start.js，之后就可以访问了【用 express 很方便】坑：将项目直接传过去之后用 npm start 启动项目完全没效果。原先的后台把端口号给禁用了。。 一般开发都是在本地，然后运行放服务器上，两边同步很麻烦，所以一般都是在服务器上弄个 git 仓库。在服务器上一般都会用 pm2 工具，他能让后台程序一直在服务器上跑。然后 pm2 里面自带一个 deployment ，可以设置后同步远程我最开始用的是尤大的 pod 工具,也是一样的逻辑，只不过稍微有点区别。 pm2pm2 的官网文档很不错官网对于pm2项目配置文件nodeserver.json,可管理多个项目123456789101112131415161718192021&#123; "apps": [&#123; // Application #1 "name": "server", "script": "./bin/www", //脚本位置，默认由 node 执行 "cwd": "./front_end", //文件启动位置 "watch": ["routes","models","views"], //监听改变自动加载 "instances": 4, //4个实例 "exec_mode": "cluster", /多核cpu模拟多进程模式 "error_file": "./log/err.log", //以下为 log 日志 "out_file": "./log/out.log", "pid_file": "./log/pids.pid", "env": &#123; //环境配置 "NODE_ENV": "development", "AWESOME_SERVICE_API_TOKEN": "xxx" &#125;, "env_production": &#123; "NODE_ENV": "production" &#125; &#125;]&#125; 如果有多个项目，再向数组里加上一个就好。配置文件可以放在根目录。运行pm2 start nodeserver.json重启pm2 restart all停止pm2 stop all关闭pm2 kill pm2开机自启动pm2 list 看到已启动的进程后 pm2 startup之后它会打印出一系列命令，中间有一部分是让你执行的，复制后执行一遍当把它所说的执行完后，会再度打印一串内容之后 pm2 save 就完成了，非常简单。 pod远端 pod create myapp 会建立一个目录 root -pod -apps +myapp -repos +myapp.git 这样就建好了一个 git 仓库本地git clone ssh://your-server/pod_dir/myapp.git然后将项目结构修改如下 nodeserver -noserver.json -README.md -apps +server]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue_live]]></title>
    <url>%2F2017%2F05%2F31%2F%E5%B0%BA%E5%B7%A5%2Fvue-live%2F</url>
    <content type="text"><![CDATA[前言参加了下尤大的live，稍微做些笔记 组件最开始开发以页面为单位，后开发网页应用后，发现可以将它进行一些切分。化为一个个组件。react：一个函数即可看成一个组件。和类很像。组件分四类展示型：接入型：和数据层打交道。对数据进行处理再向展示型组件传递交互型：elementUI,对于表单型组件进行封装功能型：’router-view’ ‘transition’ 变化侦测和渲染机制view = render(state)主要分为两种，pull和push。当系统判断数据有可能有更新，系统pull，进行暴力比对。push，数据是绑定的，有变动立马就可以知道，但是由于有watcher，开销较大。当数据有变动可以知道是哪一个组件，在组件内部再采用虚拟dom比对。虚拟节点，js生成dom，同时有一系列优化 状态管理从源事件改变状态转变ui。装填转变ui已由组件里的声明式写法做了。div @click=f 路由把 url 映射到组件树 css跟js解耦，根据命名去规范css modules 通过编译避免全局冲突css in js组件中写css 构建工具以前就是干，现在npm下一堆包任务的自动化 npm script webpack开发体验和效率部署相关的需求编译时优化 服务端数据通信请求合并， 跨平台渲染]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[blender(一)]]></title>
    <url>%2F2017%2F05%2F05%2F%E5%B0%BA%E5%B7%A5%2Fblender(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[前言因为毕设涉及到 3d 模型的原因，一直在想怎么去做，刚开始一直是想找先成的模型看有合适的就直接导入进去，找了很久没发现合适的，但是发现几个不错的网站【2333】，模型找不到后又琢磨着直接用 three 去控制顶点进行建模【这种简约风格也挺好看】，比如这个，后来稍微去看了下里面说的什么顶点生成器啥的，woc，这玩意简直不是一般的麻烦，然后这个念头也灭了，最后偶然琢磨 blender 的时候突然发现，我可以用这货直接建模啊，【很早以前也有去想学过 3d 建模啥的，3dmax 也下过，不过看着太麻烦就放弃了，到头还是绕不过去。。】调查了下发现 blender 要比其他的软件好上手很多，于是然后我就开始了又一个新坑。 基本设置上面罗里吧嗦的说了一大堆，现在来设置一些基础的东西，【其实我都是把教程上的扣下来。。】教程 blender 下载最开始是随便在网上找了一个下，今天偶然发现 steam 上竟然有，毫不犹豫的删掉了以前的又下一遍。steam 喜+1.。下载后设置一下中文语言啊，界面字体大小啥的，笔记本 1080p 看的字小的真是眼睛疼然后在设置里面把选中调成是鼠标左键选中，blender 默认的右键完全不符合人体习惯 快捷键a 全选/取消全选按住鼠标中键 旋转物体按住 shift + 鼠标中键 移动摄像机按住shift/ctrl + 滑轮 上下/左右滑动界面小键盘 调整看物体的角度ctrl + ↑ 全屏看这一部分ctrl + ← 切换模式ctrl + r 环切ctrl + u 当前工程默认为启动工程ctrl + 鼠标左键 全套选中ctrl + alt + q 切换为4分图shift + space 放大当前视图shift + a 增加物体tab 切换物体模式，编辑模式z 切换到框架模式x 删除m 层操作t 显隐工具栏n 显隐工具栏s 放大缩小r 旋转f12 渲染预览小键盘0 摄影机视角k 切割 k + z，穿透切f 选中2边或4点后点f，可在中间生成面从入门到放弃 搁浅。。做了个马克杯之后发现做完整模型太麻烦了，还是去网上下了个带贴图的模型。。。建模这个东西再次搁浅]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蜕化]]></title>
    <url>%2F2017%2F04%2F18%2F%E5%8F%B9%E8%A8%80%2F%E8%9C%95%E5%8C%96%2F</url>
    <content type="text"><![CDATA[转眼都4月份了，再2个月就毕业了。每到一件事物即将消亡的时候，人都会变得伤感起来，并不是伤感它的消亡，而是伤感自己不再拥有它的存在，即使拥有与否没有任何变化。每一次经过蜕化的时候都会把以前的东西扔掉，然后期待新的东西。可是，扔掉这些东西的时候，手心会突然被刺一下。这种感觉很奇怪，说不清到底是属于哪一种感情，也没有道理，只是让人有些不快。期待的新东西到手时也没有想象中的快乐，当时感觉很棒，可一小时后，一天后就习以为常，淡然无味，呵，无穷欲望的人类啊。 一直都是这么过来的，只是这次的不快更加强烈。站在路旁看着以前的朋友们，以前的学校，以前的我。明明才过去半年多，却都不怎么熟悉了。这些都已经慢慢在变成记忆，在慢慢沉淀，在慢慢脱离现在的我。还没有蜕化完全的我，看着眼前的世界，已经会变成另一个和我无关的世界，还存在着自己的些微痕迹，感觉很奇怪，这些只有我能看得见的痕迹。这些能证明我曾存在过的痕迹。 应该变得更好，也会变得更好。一直怀着这样的信念走过来，磕磕绊绊，摇摇晃晃，即使付出代价。不过总感觉像是在逃离以前的我]]></content>
      <categories>
        <category>叹言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[厕所堵住]]></title>
    <url>%2F2017%2F04%2F10%2F%E6%9D%82%E4%B9%B1%2F%E5%8E%95%E6%89%80%E5%A0%B5%E4%BD%8F%2F</url>
    <content type="text"><![CDATA[最近厕所被堵都总结出经验来了。。。哎蹲式厕所1.水池放慢，用水压挤下去，多重复几次。2.对着厕所洞倒清洁剂，溶解3.晾衣架折后做成勾状铁丝伸进去4.水池放满，马桶塞对着洞口压下后猛往上拉， 写的我自己都觉得恶心，哎。]]></content>
      <categories>
        <category>杂乱</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue文件引入]]></title>
    <url>%2F2017%2F04%2F07%2F%E5%B0%BA%E5%B7%A5%2Fvue%E6%96%87%E4%BB%B6%E5%BC%95%E5%85%A5%2F</url>
    <content type="text"><![CDATA[前言 vue 引用的时候出现了很多问题，综合如下。 文件引入在 webpack 中有 require 和 import 两种方法，可以看前一篇文章 vue 引入插件比如 tween jq three 等想要在每一个 vue 组件使用 在 index.html 下手动加 script 标签加载。缺点，无法应用 webpack 的打包，而且不符合模块化规范 在需要的地方使用 var name = require(‘./name’)比如var THREE = require(&#39;../../../static/three.min.js&#39;)缺点，对于每一个 vue 组件，都需要去这样写，而且还要根据文件的路径去做更改【这里可以用到别名，见最下】 绑定到 vue 全局对象，12var jq = require(./jq)Vue.prototype.jq = jq 缺点，写法麻烦，都得加 this.jq 修改 webpack 中的配置webpack.config123456plugins: [ new webpack.ProvidePlugin(&#123; $: 'jquery', jquery: 'jquery', &#125;)] 之后 import $ from ‘jquery import export文件小可以直接放到一个 js 中然后用一个对象包裹它并导出缺点，需要文件小且能放为对象格式 外部 js 获取 vue 对象1.在 main.js 配置文件中将 vue 实例 export 出来，在外部 js 中 import 。123456789export default new Vue(&#123; el: '#app', router, store, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 在外部 js 中 import vm from &#39;./main.js&#39; 之后就可以用 vm.$store,vm.$http 等等注意，如果有一个 vue 组件要去引用这个 js ，会报错 vm is not found，这个时候 vue 的实例还没有生成，而 imort 的 js 已经在去找这个实例个人认为所有的组件都执行完后 vue 实例才会生成可以使用官方提供的懒加载const Test = resolve =&gt; require([&#39;components/test&#39;], resolve)这样的话只有在访问后才会去执行这个组件中的代码 vue 引入外部css require(‘./css’) import ‘./css’ 在 style 标签下 @import ‘./css’，加 scoped=”true” 也没办法用这3种都不能固定作用域 更改 style 标签的 src1&lt;style scoped="true" src="./css/main.css"&gt; 这个可以确定作用域。 vue 加载图片 html 中写 src = &#39;~assets/logo.png&#39; 或者 :src = ‘img.src’这里的 img.src 为 data 的数据。这个数据中的 src 不能直接写原路径，必须写解析后的 src由于图片会被 loader 给解析，可能会变成 base64 格式，或者被改名加 hash 后缀等。写法如下 12var img = require('path/to/img')img.src = img; css 中，src = &#39;~assets/logo.png&#39; js 中写外部 cdn 完整路径或者 require 之后的 src background:style = style …style:{ backgroundImage: url(${require(&#39;src&#39;)})} 加载字体等特殊文件需要在 file-loader 或者 url-loader 中进行配置 使用别名在不同的路径深度中引用【import 或者 require】一个固定路径的文件时很不方便，得../../的去找，所以在 webpack 的 config 文件中定义一个 alias12345alias: &#123; static: resolve('static'), src: resolve('src'), assets: resolve('src/assets') &#125; resolve 是一个方法，如下。__dirname 是当前所在路径，path.join 是 node 的方法，拼接字符串。123function resolve(dir) &#123; return path.join(__dirname, '..', dir) //这个 '..' 是为了返回到跟路径&#125; 注意此别名路径一定要写对，否则它会去把这个别名当作一个安装的模块，到 node_modules 里去查找，然后报错找不到，提示你 npm 安装。使用：js： require(‘src/main.js’)/import a from (‘src/main.js’)html/css: src = “~assets/me.png”]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[require_import]]></title>
    <url>%2F2017%2F04%2F06%2F%E5%B0%BA%E5%B7%A5%2Frequire-import%2F</url>
    <content type="text"><![CDATA[前言最开始接触 webpack 的时候，看到里面用到 import require ，实在是没搞懂这2个有什么区别，一直到今天，又查了些资料，整理如下 import export这是 es6 提出来的规范，import export 配套使用。注意 exports , module.exports , module.require 不同，这些是 node 中的 api export 文档命名导出12export &#123; myFunction , varA&#125;; // 导出一个函数声明和一个变量Aexport const foo = Math.sqrt(2); // 导出一个常量 默认导出，一个脚本只有一个1export default myFunctionOrClass import 文档对于命名导出1import &#123;foo, bar&#125; from "my-module"; 对于默认导出，MyModule 可以更换为别的名字，因为只有一个导出。1import MyModule from "my-module"; 整体导入,没有任何绑定，会去执行 my-module 这个 js 文件当作一个副环境1import "my-module" requirerequire 是 commonjs 规范里面的，node 采用了 commonjs 格式，而 webpack 运行在 node 中的。require 主要是用来加载文件，不写相对路径，加载的就是内置模块（具体还不知道是在 webpack 中哪里设置的），node_module 中的，加了相对路径就是加载自己写的文件。require 后会去执行这个文件。 总结这两者之间有共同的部分，但是 export import 更倾向于自己去定义要导出的模块。require 倾向于去加载文件两者都是为了去模块化代码。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[活动页开发(一)]]></title>
    <url>%2F2017%2F03%2F31%2F%E5%B0%BA%E5%B7%A5%2F%E6%B4%BB%E5%8A%A8%E9%A1%B5%E5%BC%80%E5%8F%91(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[前言这次单独做了一个 app 内活动页面的开发，遇到了很多坑，在这里总结一下，都是个人意见，如果有错误，请帮忙指正。 框架webpack vue vue-router vueX jq(是不是很好奇为啥用这个。。) 开发最开始没有想用 vuex 和 vue-router 的，因为觉得页面比较简单。 vuex 的话，用起来一大串，特别长，而且遇到数组，对象啥的还容易出问题。比如一个在 vuex $store.state 中存放的数组内的一个值 a[0] 你在一个地方进行了更改，你在另一个地方发现这个值并没有改变，你必须先 a = [];a[0] = 1;这样去修改它才能发现，哦，这个值有变动，vue 中的数组和对象的检查都是这样。另一个存放在 vuex 中的数据用起来特别长的一串，写起来看起来都不舒服。 vue-router 这个最开始是没有想到的，所有的组件都是用弹窗 v-if 去判断，但是在后来的时候发现关闭当前弹窗再打开另一个弹窗的时候不好去控制动画的效果，而且切换比较麻烦，索性就直接用路由来做弹窗了，如下，这样逻辑也清楚很多，动画效果也不错。决定以后就用路由写弹窗算了 蠢，，，v-if v-else v-if-else 1234&lt;transition name="fade" mode="out-in"&gt; &lt;router-view id="zhezhao"&gt; &lt;/router-view&gt;&lt;/transition&gt; 如果站点不在根目录，webpack 需要更改脚本命令 build 中路径，改为相对 assetsPublicPath: &#39;./&#39;, 还有一个遇到的坑是在动画里面，像@-webkit-keyframes这样的，webpack打包的时候不知道为什么会出错，在打包后的文件里面你就找不到这个前缀，所以动画有的时候就不执行，后来把这个放到静态文件里面 require 进来。 另外在用 vue-resource 的时候很奇怪的发现在安卓 4.2 的 vivo 机上不起作用。不知道是请求没有发还是请求发了接受后处理的时候出了问题，后来没办法用上了 jq 里封装的 ajax 方法去请求接口。而且这个 jq 用 require 竟然还进不来，只能用 script 标签 后来没遇到过，不知道当初这个问题是什么样 除此之外遇到的 bug 全都是在那个测试机 安卓 4.2 的 vivo 手机上。。。。各种诡异。大部分时间都是改它1.圆边框出不来，是个正方形，这个样式够简单了吧border-radius:50%,可是当我又写了一个border属性的时候它就显示出一个正方形，你说气不气。2.细线出不来。想要一个 0.2px 高的细线就是不出来，后来从.01rem改到1px，scaley(.2)改到 .5 才出来3.flex布局出错，没找到原因，后来没用flex了；4.overflow:auto后竟然还可以触发被隐藏部分的点击事件（滚动条没滑到底），贼可怕，点击这个元素可以触发到兄弟元素的子元素上的点击事件。。。后来给外层又加了一个overflow:hidden的盒子才终于解决了一点，虽然还能点但是不影响功能的状态。5.动画卡，canvas 啥的基本不要想，后来做判断安卓4.4一下不执行canvas，另外在苹果 app 里的 canvas，即使把这个 webview 退到后台，好像也还是一直在执行，并且你在回去的时候如果数据量比较大会直接卡死，讲道理，退到后台之后，应该是出于暂停状态不会运行的，哎。6.不支持 vw calc 还有一些小的就不说了，这玩意简直能当作是一生之敌， 小方法匹配 url 中的某一项参数12345678var some = '', a = location.href.split('?')[1] ? location.href.split('?')[1].split('&amp;') : [];for (var i = 0; i &lt; a.length; i++) &#123; if (a[i].match(/canshu/i)) &#123; some = a[i].split('=')[1].replace(/#.&#123;0,&#125;$/, ''); break; &#125;&#125; 取 cookie 值123456var some;for (var a = document.cookie.split(';'), i = 0; i &lt; a.length; i++) &#123; if (a[i].match(/cookieeee/i)) &#123; some = a[i].split('=')[1]; &#125;&#125; vue transition 动画123456789.fade-enter-active,.fade-leave-active &#123; transition: opacity .2s&#125;.fade-enter,.fade-leave-active &#123; opacity: 0;&#125; 改 placehoder 样式1234 ::placeholder &#123; color: #999; font-size: .28rem;&#125; 最后深深的体会到了要兼容各种机子的恶意啊。。。什么时候能淘汰安卓4.4 app 内的 webview 啊。。。。简直就是ie6啊。。。。。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[canvas_hosisora]]></title>
    <url>%2F2017%2F03%2F16%2F%E5%B0%BA%E5%B7%A5%2Fcanvas-hosisora%2F</url>
    <content type="text"><![CDATA[前言从最开始了解 canvas，到现在知道了 白鹭引擎 three.js webgl。越来越觉得前端的图形学方面很深啊。。以后说不定可以做动画做原生游戏【据说知乎上有人开始用来做图片文字游戏了。。】 星空适用于手机demo这个星空可以分为四部分。1.渐变的夜空背景2.绕屏幕中心旋转的星星3.随机从右边生成的流星4.循环控制 结构首先用对象的写法，并分开定义数据和方法,这样一来思路就可以很清晰，每一帧之间直接用下一帧覆盖而不是清空，星星和流星都是有 new 和 draw 两个方法，loop 用 window.requestAnimationFrame 来循环进行帧绘制。123456789101112131415161718192021222324252627282930313233window.onload = function () &#123; hoxisora.init()&#125;var hoxisora = &#123; canvas: &#123;&#125;, ctx: &#123;&#125;, width: &#123;&#125;, height: &#123;&#125;, //star star_count: 100, star_maxR: 2.2, star_speed: 200, stars: [], //meteor meteors: [], meteor_speed: 2, time: new Date(), init: function () &#123; &#125;, new_star: function () &#123; &#125;, new_meteor: function () &#123; &#125;, loop: function () &#123; &#125;, draw_bg: function () &#123; &#125;, draw_star: function () &#123; &#125;, draw_meteor: function () &#123; &#125;,&#125; 夜空这个绘制很简单，运用 canvas 的线性渐变就能轻松的画出来。12345678draw_bg: function () &#123; var me = this, lineargradient = me.ctx.createLinearGradient(0, 0, 0, me.height); lineargradient.addColorStop(0, '#470F71'); lineargradient.addColorStop(1, '#2C63D8'); me.ctx.fillStyle = lineargradient; me.ctx.fillRect(0, 0, me.width, me.height); &#125;, 星星主要问题是绕中心旋转以及旋转的时候全屏覆盖 首先随机生成星星的对象数组，保存其位置，大小，移动速度，注意这里星星的 x，y 坐标点，生成星星的范围导致绕中心旋转的时候是否会出现屏幕的部分没有星星，即星星图的中心并不是屏幕的中心。星星的生成范围为横坐标：[(x-y)/2,(x+y)/2]纵坐标：[0,y]1234567891011new_star: function () &#123; var me = this; for (let i = 0; i &lt; me.star_count; i++) &#123; var a = &#123;&#125;; a.x = Math.floor(Math.random() * me.height) - (me.height - me.width) / 2; a.y = Math.floor(Math.random() * me.height); a.r = Math.floor(Math.random() * me.star_maxR); a.speed = Math.floor(me.star_speed + me.star_speed * Math.random()); me.stars.push(a); &#125; &#125;, save 和 restore 可以看成是新建图层和返回上一图层，translate 首先将中心移动到中点然后旋转当前画布【按时间去旋转】，不过这个时间的设定有个小bug，当一天过去时分秒毫秒都归零的时候旋转的角度会突变导致不平滑而产生卡帧的情况，也可以设到一点月或者年，一月或者一年过去的时候产生卡顿，旋转之后再将绘制相对坐标原点移回来绘制星星，这里星星采用圆点放射性渐变，注意最后 fillRect 生成的星星画布大小12345678910111213141516171819202122draw_star: function () &#123; var me = this, stars_ = []; for (let i = 0; i &lt; me.star_count; i++) &#123; me.ctx.save(); me.ctx.translate(me.width / 2, me.height / 2); let s0 = 2 * Math.PI / me.stars[i].speed * 60 * 60 * me.time.getHours(); let s1 = 2 * Math.PI / me.stars[i].speed * 60 * me.time.getMinutes(); let s2 = 2 * Math.PI / me.stars[i].speed * me.time.getSeconds(); let s3 = 2 * Math.PI / (me.stars[i].speed * 1000) * me.time.getMilliseconds() me.ctx.rotate(s0 + s1 + s2 + s3); me.ctx.translate(-(me.width / 2), -(me.height / 2)); stars_[i] = me.ctx.createRadialGradient(me.stars[i].x, me.stars[i].y, 0, me.stars[i].x, me.stars[i].y, me.stars[i].r); stars_[i].addColorStop(0, 'rgba(66,232,255,1)'); stars_[i].addColorStop(0.5, 'rgba(66,232,255,.5)'); stars_[i].addColorStop(1, 'rgba(66,232,255,0)'); me.ctx.fillStyle = stars_[i]; me.ctx.fillRect((me.width - me.height) / 2, 0, me.height, me.height); me.ctx.restore(); &#125; &#125;, 这里也可以去修改星星的亮度变化，给星星加上闪烁效果， 流星主要问题是流星的随机生成【时间，位置，速度】和角度 首先流星的生成是要有时间间隔，这里采用随机数来产生1234let i = Math.random(); if (i &gt; 0.99) &#123; me.new_meteor(); &#125; 这里注意流星的产生位置，首先是45度从右上到坐下，在屏幕中出现的范围设置为屏幕上边的[x/3,x],屏幕右边的[0,2y/3]所以流星的实际画布位置，纵坐标为了保持是在画布外出现为 -90123456789new_meteor: function () &#123; var me = this, meteor = &#123;&#125;; meteor.x = Math.floor(me.width / 3 + (me.width / 3 + me.height) * Math.random()); meteor.y = -90; meteor.speed = Math.floor(me.meteor_speed / 2 + (3 * me.meteor_speed / 2) * Math.random()); console.log(meteor.speed) me.meteors.push(meteor); &#125;, 这里画流星用了线性渐变，先生成100的正方形，然后显示只显示长130，宽1。1234567891011121314151617181920212223draw_meteor: function () &#123; var me = this, meteor_ = []; for (let i = 0; i &lt; me.meteors.length; i++) &#123; me.ctx.save(); meteor_[i] = me.ctx.createLinearGradient(0, 0, 0, 100); //长100的正方形渐变 meteor_[i].addColorStop(1, 'rgba(66,232,255,.3)'); meteor_[i].addColorStop(.7, 'rgba(66,232,255,.1)'); meteor_[i].addColorStop(0, 'rgba(66,232,255,.0)'); me.ctx.translate(me.meteors[i].x, me.meteors[i].y); me.meteors[i].x = me.meteors[i].x - me.meteors[i].speed; me.meteors[i].y = me.meteors[i].y + me.meteors[i].speed; me.ctx.rotate(Math.PI / 4) me.ctx.fillStyle = meteor_[i]; me.ctx.fillRect(0, 0, 1, 130); //只显示宽10，长100的界面 me.ctx.restore(); if (me.meteors[i].x &lt; -10 || me.meteors[i].y &gt; me.height + 10) &#123; me.meteors.splice(i, 1); &#125; &#125; &#125;, 循环循环采用 window.requestAnimationFrame1234567891011121314loop: function () &#123; var me = hoxisora; me.time = new Date(); me.draw_bg(); me.draw_star(); me.draw_meteor(); // 随机触发流星 let i = Math.random(); if (i &gt; 0.99) &#123; me.new_meteor(); &#125; me.rAF = window.requestAnimationFrame(me.loop); &#125;, 手机端出现的bug1.浮点数绘制抖动，闪烁，后来都改为整数。无法根除。。2.星星数量多后浏览器卡，3.在苹果机，星星数量会影响 requestAnimationFrame 的频率。导致动画全部变慢。4.安卓机表现不知道为什么普遍比苹果机效果好。有可能和 requestAnimationFrame 有关。5.ios 在 webview 里面，比如 app 里面或者微信，打开后再退回桌面【放到后台】，再进入网页的时候会卡掉，严重的崩溃。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[brackets_emmet]]></title>
    <url>%2F2017%2F03%2F13%2F%E5%B0%BA%E5%B7%A5%2Fbrackets-emmet%2F</url>
    <content type="text"><![CDATA[前言今天换电脑装的时候重新装 brackets 环境，还是遇到以前装 emmet 时候的问题，装不上，记得当时也是折腾了好久，最后不知道怎么的就号了。。这一次试了很多方法依旧没用，最后在知乎上找到解决方法记录如下。 解决1.首先还是在 brckets 中安装 emmet，肯定还是有问题，先不管他，让它有个目录配置文件就好。2.打开菜单-帮助-显示扩展目录，找到 user 下的 brckets-emmet 文件夹，进入后新建文件夹 node_modules 【若已有则不需要】3.npm install emmet 包后，将 node_modules 复制过去4.f5 刷新后 f12 打开控制台看报错，若报错是 ..\Brackets\extensions\user\brackets-emmet\node_modules\emmet\lib 下找不到 caniuse.json 文件，就在自己下的 node_modules 文件中全局查找该文件，然后将它复制过去。5.试试 p + table。6.成功]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[event_loop]]></title>
    <url>%2F2017%2F03%2F07%2F%E5%B0%BA%E5%B7%A5%2Fevent-loop%2F</url>
    <content type="text"><![CDATA[前言最近又遇到了当异步事件存在时，程序的执行顺序到底是怎么样的这个问题。所以再次去了解了事件循环机制。主要参考，阮大神的博客 js单线程js 是 一个单线程的语言，据说因为设计之初考虑到如果同时有一个获取节点和删除节点的操作，到底谁会被先执行。另外下面有这样一个例子可以证明12setTimeout(function()&#123;console.log(1)&#125;,5)while(true)&#123;&#125; 这个例子中 1 永远不会被打印。原因请往下看 event loop事件驱动的浏览器是多线程的，js 为处理这些多线程就使用了事件循环机制。首先明确 2 个概念1.函数调用形成堆栈2.待处理的消息形成任务队列【异步操作】 把 js 的运行想象成先编译后执行。这里以 setTimeout 来代替事件【click，mouseover等】12345678910111213function f(b)&#123; setTimeout(function()&#123;console.log(2)&#125;,0) console.log(b) return b+35;&#125;function g(x)&#123; setTimeout(function()&#123;console.log(1)&#125;,0) console.log(x) return f(4*x);&#125;g(5); 编译首先函数 g 进栈，然后调用 f 进栈，再进栈的过程中，遇到 setTimeout 会将它放入任务队列 执行首先在执行栈内的任务会被执行，当执行栈为空是会查询任务队列内的消息是否处理完【比如 setTimeout 设置5S延时】，如果执行完则去执行任务队列中的第一个消息。如此循环。123while(queue.waitForMessage())&#123; queue.processNextMessage();&#125; 所以以上的输出结果123455205512 所以，setTimeout 设置的延迟时间并不是准确时间，只是可能被执行的最小延迟，因为在它之前执行的任务队列中的消息执行时会阻塞它的执行，它必须等到之前的消息执行完才能开始执行]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo感染js]]></title>
    <url>%2F2017%2F03%2F03%2F%E5%B0%BA%E5%B7%A5%2Fhexo%E6%84%9F%E6%9F%93js%2F</url>
    <content type="text"><![CDATA[前言之前在放自己的游戏和自定义页面的时候，写的代码莫名其妙的会被转成不同的格式，比如 html 文件加很多个 &lt;/br&gt; ，js 文件加了 ‘=’ ,’ ‘,导致解析出错。没想到办法只好先生成 public 后再把页面自己放进 public 里面去。这么搞极其麻烦，不过现在找到了一种好方法 解决在 hexo 的站点配置文件 _config.yml 下有一个 skip_render 参数，使 hexo 不去渲染指定的文件或文件夹，路径相对于 source 文件夹用法如下 代码12345skip_render: - "album/vue.min.js" //针对某个文件 - "album/*" //针对某个文件夹下所有文件 - "album/**" //针对某个文件夹下所有文件及其子目录 - "album/*.html" //针对某种类型]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js继承]]></title>
    <url>%2F2017%2F03%2F01%2F%E5%B0%BA%E5%B7%A5%2Fjs%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[es5 继承es5 实质是先创造子类的实例对象 this，然后再将父类方法放到 this 上。1234567891011121314151617function Foo(v) &#123; this.value = v&#125;Foo.prototype = &#123; say: function() &#123; console.log("Foo") &#125;, hi: function()&#123; console.log("hi") &#125;&#125;;function Bar(value,name) &#123; this.name = name Foo.call(this,value)&#125;var test = new Bar(2,"cat") // 创建Bar的一个新实例 #### 如果设置Bar的 prototype 属性为 Foo 的构造函数Bar.prototype = new Foo() 这时 new Bar() 就会直接使用 new For()，虽然确实继承了 prototype 方法，但是 Bar 构造函数就会被忽略，this.name 不会被挂载所以需要加上 Bar.prototype.constructor = Bar 或者直接Bar.prototype = Foo.prototype 这里子类的 prototype 其实是父类的 prototype 的引用，所以修改子类的 prototype 也会修改父类的，所以可以采用浅/深复制来隔离开来 es6 继承es6 实质是先创造父类的实例对象 this， 然后用子类的构造函数去修改 this1234567891011121314151617181920212223242526class Point&#123; constructor(x,y)&#123; this.x = x; this.y = y; &#125; say()&#123; console.log("I'm the point") &#125; hi()&#123; console.log("hi") &#125;&#125;class ColorPoint extends Point&#123; constructor(x,y,color)&#123; super(x,y); this.color = color; &#125; say()&#123; super.say() console.log("with color") &#125;&#125;var c = new ColorPoint(1,1,'red')c.say();c.hi(); 比较。这还比较个啥，肯定新的好啊，原型继承调用父类同名方法都是个麻烦，而且实现逻辑复杂。es6 关键字 class extends 简直和 java 差不多了。装个 babel 愉快的用 es6 吧。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[rock&roll!]]></title>
    <url>%2F2017%2F02%2F25%2F%E5%8F%B9%E8%A8%80%2Frock%26roll%EF%BC%81%2F</url>
    <content type="text"><![CDATA[已经不知道多少次被感染了。深深地吸一口气，然后慢慢的吐出来。现在，凌晨 0 点。就像是生化的t病毒一样，能够迅速的在人群中传播。坐着 抖腿 点头站着 瞎蹦 摆手 哦，不需要坐着。 一旦底鼓敲响，扭大音箱失真，潜伏在人体内的病毒就发作了。 发作病表地点the beginning mv发病taka 甩起红话筒的那一刹那 地点横滨演唱会 nothing helps发病tomoya 前奏的清脆双鼓点，以及排练瞎甩膀子时 地点枪花 Sweet Child O’ Mine发病slash 的指法练习 地点G5 yamato dying to survive发病开始到结束 地点武汉草莓音乐节 ko ko mo发病大叔犀利的solo和小哥站着打鼓的姿势，这2人演出太风骚了 地点上海梅赛德斯 oor发病wherever you are 的全场手机手电筒亮起]]></content>
      <categories>
        <category>叹言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[next自定义相册]]></title>
    <url>%2F2017%2F02%2F23%2F%E5%B0%BA%E5%B7%A5%2Fnext_%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%B8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[前言对于hexo 的主题 next 搭建 blog ，还是感觉不怎么好用， 文件结构很混乱，想要改一个样式发现有好几个地方都能设置，但是效果竟然还不一样。 生成的文件也是有很多不需要的设置，臃肿。 对资源的加载速度太慢 定义了很多全局的变量，方法。自己想要在写个 js 还得考虑命名冲突问题，而且还不知道它到底定义了哪些 插件乱，虽然内置了很多插件，但是并不能很个性化的定制，还要自己一点点改。 不过。。。还是很感谢它帮我完成了自己的第一个博客吧。 相册在不少空间都有看到有很赞的图文模式，比如 lofter （pc）这样子的，所以也想去搞一个相册，放一些自己摸鱼啊拍照什么的。既然是自己写的话，就肯定做比较好用的，比如 cdn加速啊，自动化部署啊，图片懒加载啊，图片加载效果啊（比较喜欢知乎pc现在的图片加载方式） cdn加速这个就直接想到了用图床，速度肯定比我放 github 上快，并且 github 空间流量有限。所以就拿住所周知的七牛当图床了 七牛首先注册登录后就送了每月 10g 的空间和 10g 流量，还是很不错的之后就在对象存储里面创建一个存储空间，然后再开发文档里面找到 node.js sdk 照着上面 npm install qiniu 然后运行它给的那段代码就好了。之后就把链接换掉，用七牛的链接就好另外七牛可以设置图片的一些功能和样式也挺方便的 代码就比文档上给的多了一个取得所有文件名字的 node 操作。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var qiniu = require("qiniu");const fs = require('fs')const path = "./img"var file_name = [];//需要填写你的 Access Key 和 Secret Keyqiniu.conf.ACCESS_KEY = 'yours';qiniu.conf.SECRET_KEY = 'yours';//取得所有资源名字function get_file_name(path) &#123; let files = fs.readdirSync(path) for (let i = 0; i &lt; files.length; i++) &#123; if (fs.statSync(path + '/' + files[i]).isFile()) file_name.push(path + '/' + files[i]) else get_file_name(path + '/' + files[i]) &#125;&#125;get_file_name("./img") //要上传的空间bucket = 'yuicer';//上传到七牛后保存的文件名var key = []for (let i in file_name) &#123; key[i] = file_name[i].substring(2)&#125;//构建上传策略函数function uptoken(bucket, key) &#123; var putPolicy = new qiniu.rs.PutPolicy(bucket + ":" + key); return putPolicy.token();&#125;//生成上传 Tokenvar token = []for (let i in file_name) &#123; token[i] = uptoken(bucket, key[i]);&#125;//要上传文件的本地路径var filePath = []for (let i in file_name) &#123; filePath[i] = file_name[i]&#125;//构造上传函数function uploadFile(uptoken, key, localFile) &#123; var extra = new qiniu.io.PutExtra(); qiniu.io.putFile(uptoken, key, localFile, extra, function (err, ret) &#123; if (!err) &#123; // 上传成功， 处理返回值 console.log(ret.hash, ret.key, ret.persistentId); &#125; else &#123; // 上传失败， 处理返回代码 console.log(err); &#125; &#125;);&#125;//调用uploadFile上传for (let i in file_name) &#123; uploadFile(token[i], key[i], filePath[i]);&#125; 自动化部署每次加张图片还得去改代码太麻烦，所以就把图片地址单独抽出来放一个文件然后去引用它做到自动化。用 node 读取放图片的文件夹取得图片名字，然后修改后加上七牛前缀再写出到一个文本文件，之后在 js 里面去 ajax 请求这个文本文件获得地址，然后去替换 img 的 src 。因为 img 用的是 vue 的 for 循环渲染，所以相当得好替换。 破乎的加载方式先使用 canvas 显示个模糊的，可能请求了个小图然后配置到 canvas 上，然后等大图请求道后再赋到img标签上并且canvas隐藏，中间设置个动画。感觉挺麻烦的。。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[webpack配置]]></title>
    <url>%2F2017%2F02%2F04%2F%E5%B0%BA%E5%B7%A5%2Fwebpack%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言webpack 主要是用来做模块管理，但是到了现在，功能变的越来越强大，前端真是隔一两年大换血一次，感觉像什么 gulp grunt bower Browserify 到现在都被 npm + webpack 给挤下来了。对于一个大点的项目，都会分开发环境，测试环境，生产环境。解决不同环境的问题，并要做到自动化就需要用到 npm + webpacknpm 需要 node 环境，webpack 是一个包管理，直接从npm上下载。 项目结构最简单的结构，在 webpack-demo 目录下—app——main.js——greeter.js——main.css—src——bundle.js—index.html—package.json—webpack.config.js+node_modules app 中的是开发写的内容，src 是生成的静态内容，放在服务器上，webpack.config.js 是 webpack 配置文件，package.json 是安装包依赖。node_modules是依赖包，main.js 入口文件，bundle.js 打包好的出口文件， package.json创建 package.json 文件在项目里打开命令行后输入 npm init 会询问你一些问题，【可以一路回车】然后创建 package.json 文件1234567891011121314&#123; "name": "webpack", "version": "1.0.0", "description": "", "main": "index.js", "directories": &#123; "test": "test" &#125;, "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "", "license": "ISC"&#125; 然后做一些修改改为下面这个样子1234567891011121314151617181920212223 &#123; "name": "webpack", "version": "1.0.0", "description": "", "scripts": &#123; "dev": "cross-env NODE_ENV=development webpack-dev-server --open --inline --hot", "build": "cross-env NODE_ENV=production webpack --progress --hide-modules" &#125;, "author": "", "license": "ISC", "devDependencies": &#123; "babel-core": "^6.0.0", "babel-loader": "^6.0.0", "babel-preset-es2015": "^6.0.0", "cross-env": "^3.0.0", "css-loader": "^0.25.0", "extract-text-webpack-plugin": "^2.0.0-rc.3", "style-loader": "^0.13.1", "url-loader": "^0.5.7", "webpack": "^2.2.0-beta.25", "webpack-dev-server": "^2.1.0-beta.9" &#125;&#125; cross-env 使不同系统都可以设置 node 的 process.env 环境变量。cross-env其中 scripts 中写了2条命令分别对应 npm run dev 和 npm run build ,这里就要提到 npm 的脚本命令了 npm 脚本命令npm 允许在 package.json 文件中，定义 scripts 命令，如123"scripts": &#123; "build": "node server.js"&#125; npm run build 等同于 node server.js.npm 还有一个特性，它可以不加路径直接使用 node_modules/bin 下的所有脚本比如 &quot;build&quot;: &quot;./node_modules/.bin/webpack-dev-server&quot; 等于 &quot;build&quot;: &quot;webpack-dev-server&quot;原理：每当执行 npm run * 时，都会生成一个 shell ，然后去执行 接着上面的例子cross-env 是使在不同系统中都可以代码设置 node 环境变量 NODE_ENV 。它分为开发环境和生产环境，在代码中可根据判断 process.env.NODE_ENV 的值去做不同的操作dev 会去执行 webpack-dev-server ，它的作用是去开启一个本地服务器，–open 是运行完后直接打开网页，–inline 是实时监测修改并自动刷新 –hot 是热模块替换（hmr）build 会去执行 webpack ，它的作用是去打包生成静态文件，–progress 是显示打包进度另外 webpack 会将 es6 的 import export 自动解析成 es5，但是如果想用更多的 es6 语法，需要使用 babel-loader 加载器去加载解析 js webpack.config.jswebpack 的主要配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778var path = require("path") //node模块，路径解析var webpack = require("webpack") var ExtractTextPlugin = require("extract-text-webpack-plugin") //单独分离出css，需安装module.exports = &#123; entry: __dirname + "/app/main.js", //打包入口,__dirname 为项目根目录路径 output: &#123; //打包出口 filename: "bundle.js" //打包文件名 publicPath: "/publica/", //资源路径 path: __dirname + "/public", //打包文件位置 &#125;, devtool: "eval-source-map", //为了调试方便，将编译文件与源文件相对应，开了之后文件会变成几MB，只在开发中使用 module: &#123; //强大的加载器 rules: [ &#123; test: /\.js$/, //js加载器， loader: "babel-loader", //babel-loader可以使js使用es6，等新特性 query: &#123; presets: ["es2015"] //babel备注选项。 &#125; //项目大，配置多的时候会把这一项分离出去，会在项目的根目录中多出一个 .babelrc 文件 &#125;,&#123; test: /\.css$/, //css加载器 //一种写法 //loader: "style-loader!css-loader" //从右向左执行，css-loader遍历css文件，style-loader生成style标签 // 另一种写法 // use: [&#123; // loader: "style-loader" // &#125;, &#123; // loader: "css-loader" // &#125;] //运用插件将 css 从 bundle.js 分离为单独的css use: ExtractTextPlugin.extract(&#123; fallback: "style-loader", use: "css-loader" &#125;) &#125;, &#123; test: /\.(png|jpg|gif|svg)$/, //文件资源加载器 loader: "url-loader", query: &#123; name: 'img/[name].[hash:7].[ext]', limit: 10000 //小于1MB的会压缩成base64格式 &#125; &#125; ] &#125;, plugins: [ new ExtractTextPlugin(&#123; filename: 'build.min.css', allChunks: true, &#125;), ], devServer: &#123; noInfo: true, &#125;， performance: &#123; hints: false //性能评估，给定一个超过250kb的js资源，false不显示，waring给出警告，error给出报错 &#125;&#125;if (process.env.NODE_ENV === 'production') &#123; //生产环境 module.exports.devtool = '#source-map' // http://vue-loader.vuejs.org/en/workflow/production.html module.exports.plugins = (module.exports.plugins || []).concat([ new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: '"production"' //赋值 node 全局变量 &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; //压缩 sourceMap: true, compress: &#123; warnings: false &#125; &#125;), new webpack.LoaderOptionsPlugin(&#123; //webpack2的options选项不能是全局/共享的（比如之前说到的 .babelrc） minimize: true //这个插件是用来过度的。以后可能会去掉 &#125;) ])&#125; 简单的使用例子全部在一个目录下，共4个文件greeter.js123module.exports = function () &#123; ...&#125; main.js1import greet from "./greeter" webpack.config.js123456module.exports = &#123; entry: './app.js', output: &#123; filename: 'bundle.js' &#125;&#125; index.html命令行输入 webpack 进行打包加载打包完成后的 bundle.js123456789&lt;html&gt; &lt;head&gt; ... &lt;/head&gt; &lt;body&gt; ... &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 参考webpack官网入门Webpack，看这篇就够了webpack-howtovue-loaderwebpack–更优秀的打包管理工具 更新最近又去研究了下 webpack ，里面的插件还是给我搞晕了。。特别是 dev 环境下想 devServer 和 HtmlWebpackPlugin 一起使用的时候，资源的相对位置头都大了。最后还是直接把 vue-cli 的 webpack 配置直接拿过来用了。。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[es6整理]]></title>
    <url>%2F2017%2F02%2F03%2Fnew%2Fes6%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[letlet 是新增的变量声明标志，它和 var 有什么不同呢？ let是一个块级作用变量就是 {} 这个东西，它只在自己声明的块中可用，而 var 则是在声明的函数区域可用，下面附上一个简明易懂的例子12345678910111213(function () &#123; if (1) &#123; let a1 = "a1" var a2 = "a2" console.log(a1, a2) &#125; try &#123; console.log(a1, a2) &#125; catch (error) &#123; console.log("let不能在块作用域外使用") &#125;&#125;)() 用这个特性去解决循环闭包问题得到数组全是5123456789function box()&#123; var arr = []; for(var i=0;i&lt;5;i++)&#123; arr[i] = function()&#123; return i; &#125; &#125; return arr;&#125; 解决将 var i 改为 let i即可，因为原先的所有赋值都指向的是一个唯一 i，改后每次块作用域内的 i 都不同了。for 看作每一次循环重新定义这里用到了另一个特性， let 不能重复定义12345var a = 1;var a = 2; // oklet b = 1;let b = 2;// error 所以上面解决闭包的原理如下1234567891011(function()&#123; if(1)&#123; var a = 1; let b = 1; &#125; if(1)&#123; var a = 2; // 和上面的 a 是同一个，跨作用块重复声明了。 let b = 2; // 和上面的 b 不是同一个 &#125;&#125;)() let 不存在变量提升这个直接给个例子吧1234567891011(function () &#123; try &#123; console.log(a2) console.log(a1) let a1 = "a1" var a2 = "a2" &#125; catch (error) &#123; console.log("let没有变量提升") &#125;&#125;)() 所谓的变量提升就是指 var a2 = &quot;a2&quot; 会被这样解析，首先将 var a2; 这句提到函数开头，然后再原本的地方进行赋值 let 不能给window绑上属性12345var a = 1;let b = 2;window.a // 1window.b // undefined const常量，不可被改变，但注意对象和数组能够增减属性、值 解构赋值自动匹配对应结构并且赋值交换变量12var a = 1, b = 0[a, b] = [b, a] for of &amp; for inof 遍历 valuesin 遍历 keys 且，in会把遍历对象所有可枚举的属性都输出推荐数组用 of，对象用 in]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[WebViewJavascriptBridge]]></title>
    <url>%2F2017%2F01%2F17%2F%E5%B0%BA%E5%B7%A5%2FWebViewJavascriptBridge%2F</url>
    <content type="text"><![CDATA[h5现在的前端，如果在一个有app的公司，经常会有这样的要求，现在要做个活动，你给我做个h5页面，首先，什么叫做h5页面，明确来说h5指的是h5标签，或者 html5 标准。并没有什么叫做h5页面的玩意，那么为什么现在都有了h5前端工程师这个职位说法了呢?以下是我的个人看法 h5由来 hybrid app 是这一切的由来，当 web app 和 native app 开始争夺市场的时候，诞生了 hybrid app ，它使的网页能够内嵌到 app 内部里打开，具体实现便是依赖 webview 这一组件。然后由此开发出来的页面用了很多新技术，包括 html5 新增的很多内容【canvas：我是最帅的！】，呈现给用户看到的就是拽酷炫的移动端页面，然后h5这个称呼就莫名其妙的传开了。以至于现在大家一说h5，都知道是做手机页面这种。其实这个说法是不对的。 webviewwebview这个东西是app内的一个组件，有了它，在app内部就可以访问网页了，这也是为什么每一个app内部都能直接打开网页。当然这个组件也有很多坑，被称为移动端的ie6. 前端与app通信如果跑在webview上的页面想跟app之间互相调用方法的话应该怎么做呢？方法有很多，我知道的是利用 WebViewJavascriptBridge 这个第三方库去做。它的本质也是通过 webview 的代理拦截 scheme 然后注入 js 。首先需要 ios 或者 android 给 webview 将第三方库加上去。具体代码不知道。。 原理WebViewJavascriptBridge 这个第三方库运行的时候会给网页注入一个js文件，附在最下方，然后web端初始化的时候会去运行它，通过app拦截wvjbscheme这个请求，会去执行这个js文件，给全局添加一个window.WebViewJavascriptBridge 变量，这样就可以去使用它封装的方法。 web端初始化1234567891011121314151617181920212223242526//window.WebViewJavascriptBridge 为 bridge 的全名//初始化bridge对象var isInit = false, bridge_ = &#123;&#125;;window.onload = function () &#123; function connectWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125; if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125; window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement('iframe'); WVJBIframe.style.display = 'none'; WVJBIframe.src = 'wvjbscheme://__BRIDGE_LOADED__'; document.documentElement.appendChild(WVJBIframe); setTimeout(function () &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0) &#125; connectWebViewJavascriptBridge(function (bridge) &#123; isInit = true; bridge_ = bridge; &#125;)&#125; web端调用app方法1234567if (isInit) &#123; bridge_.callHandler('test_web', &#123; 'data': "test bridge" &#125;, function (responseData) &#123; console.log("done") &#125;)&#125; web端注册方法给app调用123456789_bridge.registerHandler('testJavascriptHandler', function(data, responseCallback) &#123; console.log('app called web with', data) var responseData = &#123; 'Javascript Says':'Right back atcha!' //传给app内容 &#125; console.log('JS responding with', responseData) responseCallback(responseData)&#125;) web端发消息给app123_bridge.send(data, function(responseData) &#123; consol.log('web got ', responseData)&#125;); 注入的js文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119;(function () &#123; if (window.WebViewJavascriptBridge) &#123; return &#125; var messagingIframe var sendMessageQueue = [] var messageHandlers = &#123;&#125; var CUSTOM_PROTOCOL_SCHEME = 'wvjbscheme' var QUEUE_HAS_MESSAGE = '__WVJB_QUEUE_MESSAGE__' var responseCallbacks = &#123;&#125; var uniqueId = 1 function _createQueueReadyIframe(doc) &#123; messagingIframe = doc.createElement('iframe') messagingIframe.style.display = 'none' doc.documentElement.appendChild(messagingIframe) &#125; function send(data, responseCallback) &#123; _doSend(&#123; data: data &#125;, responseCallback) &#125; function registerHandler(handlerName, handler) &#123; messageHandlers[handlerName] = handler &#125; function callHandler(handlerName, data, responseCallback) &#123; _doSend(&#123; handlerName: handlerName, data: data &#125;, responseCallback) &#125; function _doSend(message, responseCallback) &#123; if (responseCallback) &#123; var callbackId = 'cb_' + (uniqueId++) + '_' + new Date().getTime() responseCallbacks[callbackId] = responseCallback message['callbackId'] = callbackId &#125; sendMessageQueue.push(message) messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE &#125; function _fetchQueue() &#123; var messageQueueString = JSON.stringify(sendMessageQueue) sendMessageQueue = [] return messageQueueString &#125; function _dispatchMessageFromObjC(messageJSON) &#123; setTimeout(function _timeoutDispatchMessageFromObjC() &#123; var message = JSON.parse(messageJSON) var messageHandler if (message.responseId) &#123; var responseCallback = responseCallbacks[message.responseId] if (!responseCallback) &#123; return; &#125; responseCallback(message.responseData) delete responseCallbacks[message.responseId] &#125; else &#123; var responseCallback if (message.callbackId) &#123; var callbackResponseId = message.callbackId responseCallback = function (responseData) &#123; _doSend(&#123; responseId: callbackResponseId, responseData: responseData &#125;) &#125; &#125; var handler = WebViewJavascriptBridge._messageHandler if (message.handlerName) &#123; handler = messageHandlers[message.handlerName] &#125; try &#123; handler(message.data, responseCallback) &#125; catch (exception) &#123; if (typeof console != 'undefined') &#123; console.log("WebViewJavascriptBridge: WARNING: javascript handler threw.", message, exception) &#125; &#125; &#125; &#125;) &#125; function _handleMessageFromObjC(messageJSON) &#123; _dispatchMessageFromObjC(messageJSON) &#125; window.WebViewJavascriptBridge = &#123; send: send, registerHandler: registerHandler, callHandler: callHandler, _fetchQueue: _fetchQueue, _handleMessageFromObjC: _handleMessageFromObjC &#125; var doc = document _createQueueReadyIframe(doc) setTimeout(_callWVJBCallbacks, 0); function _callWVJBCallbacks() &#123; var callbacks = window.WVJBCallbacks; delete window.WVJBCallbacks; for (var i = 0; i &lt; callbacks.length; i++) &#123; callbacks[i](WebViewJavascriptBridge); &#125; &#125;&#125;)(); 更多githubfor iosmarcuswestin/WebViewJavascriptBridge某大神补充了 安卓fangj/WebViewJavascriptBridge]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[npm命令]]></title>
    <url>%2F2017%2F01%2F05%2Fnew%2Fnpm%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[建立源仓库git init --bare or git init name.git --bare前一个是把当前地址当作 git clone 目录，后一个是在当前目录再建立一个 name.git 以便 clone加 –bare 则是会建立裸仓库，不包含工作目录，只有一个 git 目录文件，只做远端的接受推送。 npm下载去官网或者安装node的时候会自带安装，之后在命令行使用就好。打开命令行的快捷方式（windows下） shell脚本 win + r 当前文件夹按住 shift 时鼠标右键点击，菜单中会出现在此处打开命令行 查看全局安装的包 npm list -g –depth 0生成package.json文件 npm initnpm outdated列出需要更新的包12345678910111213G:\yuicer\test&gt;npm outdatedPackage Current Wanted Latest Locationbabel-core MISSING 6.21.0 6.21.0 testbabel-loader MISSING 6.2.10 6.2.10 testbabel-preset-es2015 MISSING 6.18.0 6.18.0 testcross-env MISSING 3.1.4 3.1.4 testcss-loader MISSING 0.25.0 0.26.1 testfile-loader MISSING 0.9.0 0.9.0 testvue MISSING 2.1.8 2.1.8 testvue-loader MISSING 10.0.2 10.0.2 testvue-template-compiler MISSING 2.1.8 2.1.8 testwebpack MISSING 2.1.0-beta.28 1.14.0 testwebpack-dev-server MISSING 2.1.0-beta.12 1.16.2 test npm install package-name如果不加包名则根据package.json去安装。-g --save --save-dev–save 安装到 dependencies –save-dev 安装到 devDependencies -g 全局安装 git help config获取git的命令手册，在网页中打开 git config–list 检查git的配置 生成ssh密钥，在git-bash中，cat ~/.ssh/id_rsa.pub用来查看ssh密钥，如果没有则创建 ssh-keygen -t rsa -C &quot;you@mail.com&quot; 【你的git邮箱】windows下用clip &lt; ~/.ssh/id_rsa.pub来复制到剪贴板中 npm install npm@latest -g更新npm到最新版本，更新node去官网再下一个 npm update跟新依赖 git submodule add添加子模块init 克隆下来后初始化update 克隆下来后跟新]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[想想12_28]]></title>
    <url>%2F2016%2F12%2F28%2F%E5%8F%B9%E8%A8%80%2F%E6%83%B3%E6%83%B312-28%2F</url>
    <content type="text"><![CDATA[练玩琴之后看了下426的视频，其中他说到3年前一毛钱都没有的独自一人飞去日本，3年后再回上海能看到这么多小伙伴的支持。看到这一刻真的是由衷的羡慕，然后自己也想跳进单反坑。。但是我的理性正在拼命阻止我，，老话说摄影穷三代，单反毁一生 一定要慎重啊。然后看了看支付宝余额的我默默的压下了这个念头。 理想丰满 现实骨感]]></content>
      <categories>
        <category>叹言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[优雅的去掉滚动条]]></title>
    <url>%2F2016%2F12%2F26%2F%E5%B0%BA%E5%B7%A5%2F%E4%BC%98%E9%9B%85%E7%9A%84%E5%8E%BB%E6%8E%89%E6%BB%9A%E5%8A%A8%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[问题众所周知，滚动条这个东西丑，不同浏览器对滚动条的显示样式还不一样，如果是在浏览器边缘的还可以忍受，如果在页面内部出现滚动条就会让人感觉肯定是有bug，而且它还有一个问题，如果是自适应，那么滚动条出现和消失的时候会突然增加17px，造成页面抖动，布局乱掉，所以只想要滚动条的滚动功能避免掉这些问题该怎么办呢 前要 visible 默认值。内容不会被修剪，会呈现在元素框之外。hidden 内容会被修剪，并且其余内容是不可见的。scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。inherit 规定应该从父元素继承 overflow 属性的值。滚动条高度17px 测试 谷歌 百度 火狐 ie9+滚动条出现时定宽高容器的实际宽或者高会自动减去滚动条的宽或者高进行改变 首先要知道滚动条的基本机制，为什么为有滚动条出现呢，我们假设有2个 div ，div2 在 div1 的内部，当 div1 的高度或者宽度超出 div2 的时候默认是显示超出的 div1 的，因为此时的 overflow 取值为默认值 visible ,设置 auto 之后滚动条就出来了。那么这里有一个让我很困惑的问题，浏览器的滚动条是怎么出来的呢？比方说我直接设置 body { height: 1200px }html { height: 1400px }就直接出现了滚动条，这里没有任何子元素超出父元素，但是依旧出现了滚动条，这个我是理解为浏览器的一种机制，它设置了body {overflow: auto} ，这个设置很浅，可以被 html 的 css 设置 overflow 给盖掉，这样当页面元素超出屏幕可以显示的范围的时候就会出现滚动提示。这个设想不严谨，需要再考虑 思路第一个问题，让滚动条消失有2个思路 滚动条被外部元素隐藏 滚动条设置样式隐藏 第二个问题， 让滚动条一直出现，不是啥好方法。。在这里不说了 给滚动条留出距离【这个距离根据滚动条有无进行变化来让页面不抖动】 问题1方法1123body&#123; overflow:hidden;&#125; 这个方法会直接让页面不能滚动，滚动条不出现 方法2123::-webkit-scrollbar &#123; width: 0px;&#125; 这个方法让滚动条隐藏，可以滚动，但是只支持webkit浏览器，有兼容问题 方法31234567891011121314151617#div0 &#123; width: 480px; overflow: hidden; background: #333;&#125;#div1 &#123; overflow: auto; width: 500px; height: 500px; background: #666;&#125;#div2 &#123; height: 900px; background: #999;&#125; div0 包括 div1 div2这个方法让滚动条隐藏，可以滚动，但是如果是自适应的话，【滚动条根据情况出现】就会造成抖动 问题2方法1123456789101112131415161718#div0 &#123; width: 483px; overflow: hidden; background: #333;&#125;#div1 &#123; overflow: auto; width: 500px; height: 80px; background: #666; word-break: break-all;&#125;#div2 &#123; padding-right: calc(100% - 483px); background: #999;&#125; 这个方法让滚动条隐藏，可以滚动，有没有滚动条div2内的内容都纹丝不动，原理就是有滚动条的时候 div1 的宽度会自动改变，被 div2 的 100% 自动获取，就可以实现内容 padding-right 自适应，但是这个方法不适用浏览器的滚动条。 div2文本容器。内容区域只设置内容样式，同时有个自适应的右边距，div1可滚动容器。设置宽高 overflow: auto 让区域可滚动，div0多余部分隐藏容器，隐藏div1的滚动条，方法21234567891011121314151617html &#123; overflow-y: scroll;&#125;:root &#123; overflow-y: auto; overflow-x: hidden;&#125;:root body &#123; position: absolute;&#125;body &#123; width: 100vw; overflow: hidden;&#125; 此方法来自张鑫旭大神的博客这个方法我也不是很懂里面 root 设置的属性。。。不过核心就是 body 的 width: 100vw 固定body宽不受滚动条影响，不过这个会导致出现横向滚动条，所以还得加上 overflow-x: hidden]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内部滑动不触发外部滑动]]></title>
    <url>%2F2016%2F12%2F24%2F%E5%B0%BA%E5%B7%A5%2F%E5%86%85%E9%83%A8%E6%BB%91%E5%8A%A8%E4%B8%8D%E8%A7%A6%E5%8F%91%E5%A4%96%E9%83%A8%E6%BB%91%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[问题最近工作的时候遇到一个问题，在页面中如果出现了2个滑动元素，比如浏览器的滚动条和一个div内的滚动条，当div内部的滚动条滚动到最底部的时候，接下来会默认触发浏览器的滚动条，这是浏览器的默认行为，是没有任何问题的，但是！在特殊情况，不想让外面跟着滚怎么办呢？ 要求内部滑动到最上的时候再往上滑无效，同理滑到最下。 思路首先想到 onscroll 事件，可是无奈这个不能判断鼠标发生上下滑动，好像可以用 event 鼠标的位置，但是1鼠标的位置可能根本就不动，虽然听说有 event.scrollx 这个东西，但是在谷歌测试没发现，2他获取的位置是滑动事件发生之前的位置，所以这个没用 第二个想到 onwheel 事件，可惜这个还是没办法判断鼠标发生上下滚动 最后找到了 onmousewheel 事件和 DOMMouseScroll 事件 demo 重点在除ff浏览器有一个 onmousewheel 事件，用 wheelDelta 和 scrollTop 进行判断，然后直接返回 false 就可以1234567a.onmousewheel = function (e) &#123; if (a.scrollTop == 0 &amp;&amp; e.wheelDelta &gt; 0) return false; if (a.scrollTop == a.scrollHeight - a.clientHeight &amp;&amp; e.wheelDelta &lt; 0) return false;&#125; 但是ff浏览器就没有这个事件，它只有一个 DOMMouseScroll 事件，而且这个事件还得自己去绑上去 addEventListener ，本身是没有的，并且不让他滚动只能用 e.preventDefault() 这个事件，然后让它能再滚动只能去除 eventlistener 事件，超麻烦。。想了很久之后想出了以下办法，测试没有问题123456789101112131415a.addEventListener("DOMMouseScroll", f2) function f2(e) &#123; if (a.scrollTop == 0 &amp;&amp; e.detail &lt; 0) &#123; e.preventDefault(); a.removeEventListener("DOMMouseScroll", f2) a.addEventListener("DOMMouseScroll", f2) return; &#125; if (a.scrollTop == a.scrollHeight - a.clientHeight &amp;&amp; e.detail &gt; 0) &#123; e.preventDefault(); a.removeEventListener("DOMMouseScroll", f2) a.addEventListener("DOMMouseScroll", f2) return; &#125; &#125; 其他其实除了这个外，还有个抖机灵的方法，就是 body 设置一个高，然后 overflow:hidden 原理是让 body 【浏览器的滚动条消失，即外部滚动失效】 但是有时候页面会跳到 overflow 页面最上面，可以再加上scroolTop去定位到原先位置，不过这个方法还是会出现body的滚动条抖动，而且逻辑略微复杂。根据情况，也是一个不错的方法。 补充此方法当元素a本身不可滑动时，在a上面滑动也是不会触发页面的滑动的。如果想要对此修改，请自行判断 另外滚动条抖动的解决办法会在另一篇文章里说到。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何礼貌的回不想回的人]]></title>
    <url>%2F2016%2F12%2F21%2F%E6%9D%82%E4%B9%B1%2F%E5%A6%82%E4%BD%95%E7%A4%BC%E8%B2%8C%E7%9A%84%E5%9B%9E%E4%B8%8D%E6%83%B3%E5%9B%9E%E7%9A%84%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[利用tcp或者http高逼格的回复对方，会惹对方生气，，尽量不用吧tcp对话 f 在吗?[5分钟延迟]t 在f 有个事你给帮个忙[5分钟延迟，且产生丢包]t 啊？f 就balabala这事，你尽快搞完然后回我t 哦 tcp过程产生延迟，丢包现象不可避免 http回应对方 418 卖萌200 好202 哦100 你继续301 找他吧，这事我不管302 这回你找他去吧404 你被我拉入黑名单403 拒绝你的要求500 不知所措503 现在不行，等会把]]></content>
      <categories>
        <category>杂乱</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[转变]]></title>
    <url>%2F2016%2F12%2F21%2F%E5%8F%B9%E8%A8%80%2F%E8%BD%AC%E5%8F%98%2F</url>
    <content type="text"><![CDATA[偶然的停下来看了看时间，现在是12月21号了，在公司上班也已经2个多月了，现在停下来想了想，9月份找工作的那一个星期好像离我很遥远了。不由的感叹时间真是能让人习惯任何事情。 记得那个时候天还很热，太阳还是晃眼睛，每天早出晚归到处跑招聘会。因为学校在三环外，去哪里都远，武汉的交通又差，所以坐了几次公交之后就开始滴滴打车，那几天真体会到什么叫花钱如流水。看着支付宝的那几个数字每天小一点，每天小一点。心疼的我只好安慰自己说这是给自己的投资。打车的时候遇到了好多司机，经常跟他们聊天。他们大多都是看着私家车出来挣点外快，其中和有几个司机的说话时真的感觉到人活着是很累的啊，人到三十，上有老，下有小，公司家庭压着，还谈个什么梦想，每天就纯粹为了挣钱罢了，不求大富大贵，只求平平安安。以前的我很是不屑平平安安，庸庸碌碌的活。想着自己是不同的，自己能够做到一切想做的事情。到了如今，我也慢慢觉得中庸也没什么不好，也理解到自己也是一个普通人，和几十亿人没什么不同。生活真是不容易 找工作的过程意外的不是很艰难，最开始的去投了bta这种大巨头。不过理所当然的挂了，记得当时接腾讯的面试电话一共就打了4分多钟，现在想想真是辛苦了那个面试官，碰到我这么一个小白，问啥啥不会，最后还得照顾我的心情，得委婉的挂电话。这通电话让我一下子清醒了过来，清清楚楚的把我身上打上了一个标记，让我认清了自己的能力，所以我还是很感谢这个和我说了4分钟话的面试官。招聘的分3批，第一批巨头9月或更早，第二批中等10月，第三批11月。这之后我对于能进大公司基本没抱期望了，去招聘会也纯当是去涨姿势了。不过不得不说，大公司里的人确实给人感觉不一样。记得最清楚的是小米招聘会的那个宣讲人，说话真的很厉害，就好像以前的那种贵族绅士一样，对人【即使是我们这些去招聘会的人】很尊重，位高的人能够对位低的人保持尊重，光这一点我就觉得很难了。说话也是给人一种聪明的感觉，一直在笑着，仿佛一切都在掌握。我自己对聪明的人是这么定义的【达成自己的目的的同时让他人感到开心】，这是我遇到的第一个做到了这一点的人，也让我感叹果然人和人的差距能够达到人和猴子这么大。 之后又面试了4次，其中的一次面试是在我宣讲会坐完卷子的第二天给我发了面试，当时以为是那个大公司，去了之后发现要我的是这个大公司进行投资了的一个小公司的老板，和这个大公司没任何关系。。。面了大概半个小时他就当场跟我说要我了，连工资都告诉我了。。。当时真的是超开心，因为这之前只面过一个58，而且面的当场我就感觉我挂了，因为他问我关于ie的时候，我直接说没研究过，也不打算去管他，这玩意早该过时。然后那个面试官就不开心了。。。 拿到了人生的这第一个offer之后我一下子觉得找工作不难，因为我自己对于前端在大学的水平属于切切图，排排版的水平，就在7,8月份的时候闭关2月做了一个个人介绍网站，网站分三块，第一块是个svg动画介绍我自己的，第二块是做了个播放器，第三块做了一个射击的小游戏。后来的事实证明，这个网站确实帮了我不少忙。拿到offer后整个人就松下来了，对于招聘会也是看的顺眼的才去，之后又跑了2天没什么进展就直接没跑了，就这样我找工作的事情就结束了，之后又收到了3家公司的面试，最后还是选择了这个当场要我的小公司。现在想想，如果我找到之后没有那么松懈，再多跑跑，今天是否会不一样呢？。 之后去公司发现这真的是个小公司，，前端就2人。。我一个，还一个一年的。整个公司就30人左右，woc，这没人带怎么搞，项目不会做怎么搞，当时老板甩给我任务的时候整个人都是楞逼的。看着前任留下来的代码死活看不懂，注释都没有，也没交接文档，吐血啊，后来跟另个人商量直接推掉重做了，之后2个星期就各种恶补，竟然还真给做出来了。。。前端这一套搞下来之后【虽然没自动测试和自动发布】，涨了一大堆经验，发现前端的路一下子宽了很多，要学的东西也还有很多，虽然磕磕绊绊的，现在的我也能够上手工作了，可喜可贺。在公司的这2个月真的学了很多东西，比起暑假那2个月见识开广了很多。 昨天摸鱼的时候偶然点开了保存了好久的一个莴苣的博客，转了一圈之后立马献出了我的膝盖。大家可以想象一下，一个高中生，但是做的项目是你的好几倍，而且会音乐，画画，看的书又多。而且而且还是一个高中生。这种人生真是让人羡慕。痛定思痛，反思了下我和莴苣大大的差距。自己的技能点都不知道瞎点到哪里去了，吃啥啥没够，干啥啥不精，不努力，还老贪玩。哎。。人艰不拆。 这2个月来真的让我变了不少，得到了很多，也失去了很多，想起yui的tokyo那首歌。何かを手離してそして手に入れる、そんな繰り返しかな。就这样慢慢的来吧，慢慢的越变越好。一年以后，我能够看的更远，飞的更高，]]></content>
      <categories>
        <category>叹言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深复制]]></title>
    <url>%2F2016%2F12%2F20%2F%E5%B0%BA%E5%B7%A5%2F%E6%B7%B1%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[var arr = [“One”,”Two”,”Three”]; 数组的浅复制var arrto = arr; 数组的深复制var arrtoo = arr.slice(0);var arrtoo = arr.concat(); 对象的深复制function deepCopy(source) { var result = {}; for (var key in source) { result[key] = source[key]; if (typeof (source[key]) == “object”) { deepCopy(source[key]); } } return result;}]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js小知识]]></title>
    <url>%2F2016%2F12%2F20%2F%E5%B0%BA%E5%B7%A5%2Fjs%E5%B0%8F%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[强烈推荐javascript秘密花园 undefined null 不能看作对象，其他都可做对象变量做属性名12345var A = &#123;one : 1&#125;A.one // 1var b = "one"A.b // undefinedA[b] // 1 3种情况循环12345678910var a = 2, flag = 0;for(let i = 0, i &lt; 100,i++)&#123; flag = i % a; if(flag == 0) dosomething else if(flag == 0) dosomething else if(flag == 0) dosomething&#125; 字符串转换为数字1234567+'010' === 10Number('010') === 10parseInt('010', 10) === 10 // 用来转换为整数+'010.2' === 10.2Number('010.2') === 10.2parseInt('010.2', 10) === 10 常用转换‘’ + 10 === ‘10’; // true+’10’ === 10; // true 定时器setTimeout 执行的时候this指向的是windos对象， var t = setInterval(function(){},1000) clearInterval(t); 获取元素样式1.获取 dom 节点后，dom.style 进行赋值，但是这是改的html的行内样式。2.getComputedStyle()getComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值。语法如下： window.getComputedStyle(&quot;元素&quot;, &quot;伪类&quot;); 这个方法接受两个参数：要取得计算样式的元素和一个伪元素字符串（例如“:before”） 。如果不需要伪元素信息，第二个参数可以是null。也可以通过document.defaultView.getComputedStyle(“元素”, “伪类”);来使用例子： var test = document.getElementById(&quot;test&quot;), demo = window.getComputedStyle(test, null); //获取节点的color demo.color 避免js堵塞1.XHR注入：就是用ajax异步请求同域包含脚本的文件，然后将返回的字符串转化为脚本使用，该方法不会造成页面渲染和onload事件的阻塞，因为是异步处理，推荐使用。 2.iframe注入：加载一个iframe框架，通过使用iframe框架中的脚本来避免src方式加载脚本的阻塞，但是iframe元素开销较大，不推荐。 3.DOM注入：就是创建script元素，通过制定该元素的src并放入DOM树中，根据该语句书写的文字不同，会造成渲染或onload事件的阻塞。 document.write方法：在JS脚本中使用document.write(‘XXX‘);这种方法简单粗暴，但是它仍然会造成阻塞，所改变的只是什么时候阻塞。dom操作dom 操作费时费力，尽量不用 DOM(Document Object Model/文档对象模型)是针对HTML和XML文档的一个API。DOM 节点树：在文档中出现的空格、回车、标签、注释、文本、doctype、标签等都属于DOM节点。 操作 DOM 节点的方式无非就是：创建、添加(插入)、移除、替换、查找(获取)、克隆 DOM 节点。 创建文本节点：var newText = document.createTextNode(‘文本节点’);创建标签节点：var newNode = document.createElement(‘div’); 添加(插入)子节点至末尾：父节点.appendChild(子节点);添加(插入)子节点至某节点前：父节点.insertBefore(子节点, 某节点); 移除子节点：父节点.removeChild(子节点); 替换节点：父节点.replaceChild(替换后的节点, 替换前的节点); 查找(获取)节点：查找(获取)所有子节点：父节点.childNodes查找(获取)所有是标签类型的子节点：父节点.children查找(获取)下一个兄弟节点：某节点.nextSibling查找(获取)上一个兄弟节点：某节点.previousSibling查找(获取)父节点：子节点.parentNode查找(获取)第一个子节点：父节点.firstChild查找(获取)最后一个子节点：父节点.lastChild]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字体]]></title>
    <url>%2F2016%2F12%2F20%2F%E5%B0%BA%E5%B7%A5%2F%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[最近一直疑惑这个blog主题的字体设置是怎么来的，看到样式写的是font-family: ‘Lato’, “PingFang SC”, “Microsoft YaHei”, sans-serif;但是又一直找不到这个字体是怎么加载进去的，查了很长时间，在此记录如下 LatoLato这个字体是英文字体，下载链接在google fonts上面，因为是英文，所以字体并不大，这个字体的设置是在主题配置文件中的font下的global中，用的谷歌的外联，但是这个由于墙的原因，很大几率加载失败，虽然这个字体只有50到100kb，然后备用字体是sans-serif 额，又测了几遍，发现意外的速度超快。。请求头http://fonts.gstatic.com,ip是203.208.39.207 然后这个ip竟然是北京海淀的。。。woc，以后都直接外链吧。。。大谷歌威武 PingFang SC这个据说是苹果的中文字体，但是在blog中并没有看到有下载或是引用这个的，估计应该只是为苹果用户专留的吧，实测使用的是微软雅黑这个字体 font字体的话现在使用下面这样的外来字体比较多了，毕竟自带的每个系统都不一样而且满足不了需求还丑 @font-face { font-family: ‘Poiret One’; src: url(‘../font/poiretone-regular-webfont.woff2’) format(‘woff2’), url(‘../font/poiretone-regular-webfont.woff’) format(‘woff’); font-weight: normal; font-style: normal; }不过用中文字体的话字体文件就很大了，看到有说woff这个格式的字体压缩的好，比ttf要小很多，不过对于等它的压缩方式还不是很了解，以后在去补补字体的压缩这方面内容吧。字体这个东西一般是要做适配降级的，面对不同的系统，不用的需求，也要考虑到打开速度，比如手机用字体的话下载就会很慢。总的来说，这个东西还是要衡量着用。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[svgo]]></title>
    <url>%2F2016%2F12%2F16%2F%E5%B0%BA%E5%B7%A5%2Fsvgo%2F</url>
    <content type="text"><![CDATA[svgonpm install -g svgo //安装svgo svgo -f svg(文件夹名字 ) //对文件夹里面的svg进行操作 svgo -f svg -o output //输出到平级的另一个output文件夹 svgo test.svg //对单个文件操作 这个工具会把ps生成的svg精简很多，不过其中一个 fill （颜色）会保留，如果需要得自己去修改svg的话属于矢量图，而且代码形式存在，比直接用图片要快的多，节省很多http请求，而且也快，支持js，css控制。超强不过一般设计不会给这个。。。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[三种二叉树建立]]></title>
    <url>%2F2016%2F12%2F16%2F%E5%B0%BA%E5%B7%A5%2F%E4%B8%89%E7%A7%8D%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E7%AB%8B%2F</url>
    <content type="text"><![CDATA[第一种12345678910111213141516171819Node* CreatTree() //无参数 &#123; char ch; Node *T; cin &gt;&gt; ch; if(ch =='?') &#123; T = NULL; &#125; else &#123; T = new Node; T-&gt;date = ch; T-&gt;lchlid = CreatTree(); T-&gt;rchild = CreatTree(); &#125; return T; &#125; 第二种123456789101112131415161718Node* CreatTree(Node*&amp;T) //有参数 注意会改变指针的值即T = NULL 所以必须用引用&amp; &#123; char ch; cin &gt;&gt; ch; if(ch =='?') &#123; T = NULL; &#125; else &#123; T = new Node; T-&gt;date = ch; CreatTree(T-&gt;lchlid); CreatTree(T-&gt;rchild); &#125; return T; &#125; 第三种12345678910111213141516171819void CreatTree(Node*&amp;T) //返回值无参，和第二个类似，（其实一样）本来第二个也不需要返回值。 //因为返回的就是自己输入的那个参数。 &#123; char ch; cin &gt;&gt; ch; if(ch =='?') &#123; T = NULL; &#125; else &#123; T = new Node; T-&gt;date = ch; CreatTree(T-&gt;lchlid); CreatTree(T-&gt;rchild); &#125; return ; &#125;]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[绑定顶级域名到github_pages]]></title>
    <url>%2F2016%2F12%2F15%2F%E5%B0%BA%E5%B7%A5%2F%E7%BB%91%E5%AE%9A%E9%A1%B6%E7%BA%A7%E5%9F%9F%E5%90%8D%E5%88%B0github-pages%2F</url>
    <content type="text"><![CDATA[首先需要一个域名随便去哪买一个呗，又不算贵。。 当时不知道，买了个最贵的.com。 设置gtihub.iousername自己取名字首先去github建立一个username.github.io仓库，这个仓库是github专门给每一个用户留出的一个展示自己网页的【github pages】，把内容传到这个仓库之后，直接访问username.github.io就可以看到你的github pages。如果想要绑自己的域名，先去买个域名，然后设置dns，再传一个CNAME文件到github仓库。注意这个文件没有后缀文件内只写入 username.com dns设置添加两条记录，这样访问以下三个url都能访问到 username.github.iowww.username.comusername.com CNAME @ username.github.io CNAME WWW username.github.io 想更详细的看如何设置解析点这里 github仓库限制GitHub Pages源文件库的建议限制为1GB。发布的GitHub Pages网站不大于1GB。GitHub Pages网站的流量限制为每月100GB。GitHub页面网站的限制为每小时10个构建]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动端适配]]></title>
    <url>%2F2016%2F12%2F14%2F%E5%B0%BA%E5%B7%A5%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[rem布局viewport首先明确width，移动端的物理宽度，手机宽度这个完全没关系，另外有个三个viewport的说法 layout viewport 的宽度是大于浏览器可视区域的宽度的，这个是当有些网页没有做移动端适配但是依旧可以打开，只不过看到的都很小，这种情况就是layout。这个宽比较大，大概1000多吧，是让这些pc的网页可以在手机上看的宽 visual viewport 的宽度是浏览器的可视区域宽，window.innerWidth可以获取到，可以理解为屏幕宽吧 ideal viewport 的宽度是为了方便设计网页开发的，当然不同的设备也不一样，但是他是可用的，比如苹果的手机大屏plus和小屏（同一个版本），他的这个宽是一样的，比如iphone 6为375，一般得安卓为360.而这个是我们要使用的，为啥不用上面的，不也有默认宽吗，因为那样的会出现滚动条，效果不好，所以才会有现在的这个东西。当然这个也超级麻烦。。。分好多好多种，325,360,375,414,768（ipad）,1024（平板）。粗略统计 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;&gt;所以一般会加上这么一句话，不过后面的阻止缩放在很多浏览器并没用 设置rem然后为了布局在这么多不同的宽度适应，一般用rem来布局， rem是相对于根元素的font-size区设置的，所以就需要动态的改变它 html { font-size: calc(100vw/3.75); //font-size小于12px浏览器就不支持了 //1rem等于100px，相对于iphone6 } body{ font-size: 16px; } 或者使用媒体查询,这个要多设几个断点， @media only screen { html { font-size: 30px; } } @media only screen and (max-width: 479px) and (min-width: 321px) { html { font-size: 15px; } } @media only screen and (max-width: 320px) { html { font-size: 13px; } } 宽度一般用rem或者百分百，高度则一般用px。 flex布局盒子设置.box{ display: -webkit-flex; display: flex; } 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 盒子属性flex-direction row(行) row-reverse column(列) column-reverse 确定主轴方向flex-wrap wrap nowrap wrap-reverse 换不换行flex-flow 上面2个属性简写 默认row nowrapjustify-content flex-start | flex-end | center | space-between | space-around 主轴对齐方式 默认左对齐align-content flex-start | flex-end | center | space-between | space-around | stretch 多行多根主轴对齐方式 默认stretch 占满 只有一行则无效align-items flex-start | flex-end | center | baseline | stretch 侧轴对齐方式 默认stretch 占满 内容属性order 自定义顺序 负值在最前 0不变 正值互相比较排序flex-grow 放大 默认为0 不放大，保持原尺寸 为1若有剩余空间则自动放大填充满flex-shrink 缩小 默认为1 缩小，若空间不足则缩小上面2个属性不可为负，若为大于1的正值，则相对其他元素进行比较，收缩或放大的程度更大flex-basis 默认为auto，即元素本来的大小，浏览器根据这个属性，计算主轴是否有多余空间。可设置为px，效果和width差不多。flex 上面3个值的简写，单写一个数字为flex-grow的值，后2个值缺省为1和0%align-self 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。 flex布局确实要比以前的float position要方便的多，而且适应性好，移动端的话 flex布局要比rem布局方便一点，不过没有rem精确]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二十八星宿]]></title>
    <url>%2F2016%2F12%2F09%2F%E6%9D%82%E4%B9%B1%2F%E4%BA%8C%E5%8D%81%E5%85%AB%E6%98%9F%E5%AE%BF%2F</url>
    <content type="text"><![CDATA[天之四灵 以镇四方 此为四象东方青龙角木蛟 亢金龙 氐土貉 房日兔 心月狐 尾火虎 箕水豹角：为东方七宿之首，属于室女座，有二星，角宿一为一等星，其光为白色，象征着造化万物，天下太平。亢：为「青龙」东方之第二宿，有四星，皆属于室女座，为三等星，其星如明亮代表平安无疾，如暗，则象征有天旱，或瘟疫。氐：为东方七宿之第三宿，天秤座，有四星，为主疾病之星。房：为东方七宿之第四宿，属天蝎座，有四星，其星明象征着政清明，百姓安乐。心：为东方七宿之第五宿，有三星，属于天蝎座，心宿二为一等星，其色为红，又称为商星代表文明昌盛。尾：为东方七宿之第六宿，有九星，属于天蝎座，俗称龙尾九星，其星明，象征五谷丰收，如暗有洪水之患。箕：为东方七宿之第七宿，有四星，属于人马座，斗在北，箕在南，又名「南箕」，清明代表风调雨顺，五谷丰收。 南方朱雀井木犴 鬼金羊 柳土獐 星日马 张月鹿 翼火蛇 轸水蚓井：为南方「朱雀」七宿之首，有八星，属双子座，此星明亮，代表国富民安，天下太平，如色变则动荡不安。鬼：为南方七宿之二，有四星，属巨蟹座，星色很是暗淡，如云非云，如星非星，为不祥之兆。柳：为南方七宿之三，有八星，属长蛇座，其星明，亮主百姓丰衣足食，如果失其色，则失收饥荒。星：为南方七宿之四，有七星，属长蛇座，此七星代表有偶发性之急事。张：为南方七宿之五，有六星，属长蛇座，其星明亮，代表国强民富。翌：为南方七宿之六，通「翼」，有二十二星，十一星属巨爵座，三星属长蛇座，另外八星不明，其星明亮，象征礼乐与兴邦等，四海一心。轸：为南方七宿之七，末也，有四星，属乌鸦座，其星明亮，代表风调雨顺，天下太平。 西方白虎奎木狼 娄金狗 胃土雉 昴日鸡 毕月乌 觜火猴 参水猿奎：为西方七「白虎」七宿之首，有十六星，其中分别属仙女座与双鱼座，均代表文昌盛世。娄：为西方七宿之二，有三星，属白羊座，其星明，象征国泰民安，否则兵乱四起。胃：为西方七宿之三，有三星，属白羊座，「胃」为天仓，粮库也，星明代表五谷丰收。昴：为西方七宿之四，有七星，六星属于金牛座，即是所谓七姊妹星团，此星明朗代表安和乐利，天下太平，星暗则忧虑多也。毕：为西方七宿之五，有八星，属金牛座，毕宿五为一等星，色是赤色，俗称金牛之目，象征兵马军力之权。觜：为西方七宿之六，有三星，属于猎户座，此星明，代表安和乐利，五谷丰收，若有移位，象征君臣失位，兵马动乱。参：为西方七宿之七，末星也，有七星，属猎户座，此星明亮，代表民生乐利，风调雨顺，五谷丰收。 北方玄武斗木獬 牛金牛 女土蝠 虚日鼠 危月燕 室火猪 壁水獝斗：为北方「玄武」七宿之首，属于人马座，有六星，又称「南斗」，与「北斗七星」遥相呼应。其易明代表天下太平，国富民安。牛：为北方七宿之第二星宿，有六星，属摩羯座，又名「牛郎星」或牵牛星，其星明象征六畜兴旺，五谷丰收，安乐和利。女：为北方七宿之第三星宿，有四星，属宝瓶座，此星象征女性，清明，代表妇女昌盛，女权主事。虚：为北方七宿之第四星宿，有二星，属宝瓶座与小马座，为美丽双星，清明，代表天下太平，安康快乐之事，其星暗，则指有动洫不安，兵乱无宁。危：为北方七宿之第五星宿，有三星，一星属宝瓶座，二星属飞马座，见危则不安，暗则主有大灾难。室：为北方七宿之第六星座，有二星，属飞马座，此星明，象征国运昌隆，百姓乐，利如暗则天下大乱，瘟疫横行。壁：为北方七宿之第七宿，尾后之「末也」，有二星，分别属飞马座与仙女座，壁宿二为二等星，星明代表文人当道、当权、道德昌盛，君子明进，小人不见。]]></content>
      <categories>
        <category>杂乱</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[三山五岳]]></title>
    <url>%2F2016%2F12%2F09%2F%E6%9D%82%E4%B9%B1%2F%E4%B8%89%E5%B1%B1%E4%BA%94%E5%B2%B3%2F</url>
    <content type="text"><![CDATA[三山五岳蓬莱方丈【方壶】瀛洲 这三山都是神仙住的，其实三山原有五山，以下为列子.汤问中原文描述 渤海之东不知几亿万里，有大壑焉，实惟无底之谷，其下无底，名曰归墟。八弦九野之水，天汉之流，莫不注之，而无增无减焉。其中有五山焉：一曰岱舆，二曰员峤，三曰方壶，四曰瀛洲，五曰蓬莱。其山高下周旋三万里，其顶平处九千里。山之中闲相去七万里，以为邻居焉。其上台观皆金玉，其上禽兽皆纯缟。珠玕之树皆丛生，华实皆有滋味，食之皆不老不死。所居之人皆仙圣之种；一日一夕飞相往来者，不可数焉。而五山之根，无所连箸，常随潮波上下往还，不得蹔峙焉。仙圣毒之，诉之於帝。帝恐流於西极，失群仙圣之居，乃命禺彊使巨鼇十五举首而戴之。迭为三番，六万岁一交焉。五山始峙而不动。而龙伯之国，有大人，举足不盈数千而暨五山之所，一钓而连六鼇，合负而趣，归其国，灼其骨以数焉。於是岱舆员峤二山流於北极，沈於大海，仙圣之播迁者巨亿计。帝凭怒，侵减龙伯之国使阨。侵小龙伯之民使短。至伏羲神农时，其国人犹数十丈。 大意讲的是渤海之东有归墟，这个大家都知道吧，很多小说都有写这个的，说是归墟下为黄泉，零魂聚集之处。写的比较细的有《商博良.归墟》，不过这是个坑，出自一向挖坑不填的江南，铁甲现在都锈了。继续接着说，归墟中有五座山。上面都是金銮殿，白色神兽，吃了能不老不死的果实花朵，住的都是神仙，五山没有根，在海上一直漂，上面的帝【我也不知道这个到底是谁】怕山跑西边去了，神仙都没家了，就放了15只乌龟抵住5座山，每座山3只乌龟顶着不让动。可是后来龙伯国有个巨人跑海边来钓走了6只乌龟。。。然后这2座山岱舆员峤就漂到了北边沉到大海了，好多神仙家没了，然后帝很生气，把龙伯国的地盘慢慢缩小，人也给慢慢变小，但是一直到伏羲神农的时代那儿的人还有几十丈高。 不过这都是古代人想的了，水都去归墟是因为地势西高东低，所以都往东流，古人想不通水为啥有增无减所以就整了个归墟，其实就变成水蒸气循环了。然后海上面的山都是海市蜃楼出来的，不过那时人不知道，还导致好多皇帝派人去海上找长生不老药，不过这也促进了国家文化的交流，比如异邦人里的背景设定就是这个原因。 泰山衡山华山恒山嵩山 东岳泰山如坐南岳衡山如飞西岳华山如立北岳恒山如行中岳嵩山如卧 这是形容五岳的句子，五岳说法很早，好像和皇帝封禅，道教兴盛有关]]></content>
      <categories>
        <category>杂乱</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[博客搭建工具 hexo 使用]]></title>
    <url>%2F2016%2F12%2F08%2F%E5%B0%BA%E5%B7%A5%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%B7%A5%E5%85%B7%20hexo%20%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言一直都想有一个自己的博客，最后找到了 hexo 这个可以迅速搭建个人博客的工具，在这里记录用法 配置首先安装node，npm，服务器可以使用 githubpages 提供的免费服务，这个服务是 github 对仓库名为 name.github.io 【自己建的仓库】配置了一个服务器，可以直接通过 name.github.io 这个地址访问。hexo安装后，大多数的配置都在根目录 _config.yml 中，进入文件夹使用 hexo init blog 就会建立blog文件夹并自动安装一个demo和依赖，之后 npm install hexo-deployer-git --save ，安装这个后可以通过命令 hexo deploy 更新 blog 到 githubpages 上。不过需要配置 _config.yml 下的 deploy 如下，name为你自己取的仓库名1234deploy: type: git repo: https://github.com/name/name.github.io.git branch: master 主要命令`hexo new [layout]&lt;file&gt; ` 新建文件，有三种，layout为模式，有draft page post三种 默认为post，即发布模式，draft为草稿模式，page为页面模式，file为文章名字1234567hexo server //开启端口4000的本地服务器hexo generate //渲染生成静态文件网页hexo deploy //推送到远程站点hexo new &lt;file&gt; //默认为post模式，hexo new draft &lt;flie&gt;//换到草稿模式，草稿模式默认不渲染发布。 hexo publish [layout] &lt;file&gt; //将草稿变为发布，layout默认为drafts文件夹，可以理解为写的草稿发布 另外有个 scaffolds 文件夹，里面存的是模板, hexo new [layout] &lt;file&gt; 中生成的内容就是从这里面读取，在这里修改后以后的 new 出来的初始文件都会跟着改变更多详情 主题使用hexo主题主题推荐使用 next， 这个系统很完善，有各种已经内置好的插件可以直接设置，这是这个主题的 . 官网这里内置插件有评论，站点统计，打赏，全站查找，图标，分享，友链等等。具体设置在主题下的 _config.yml 文件中。 添加hexo clean 清除 public 文件夹中的东西，这个在生成文件或者开服务器的时候用下，不然可能会出现莫名其妙的bug 自定义样式来自浚宇的博客 修改侧边栏在next主题中，比如Pisces中，侧边栏和上边的站点概述中的分类等有联系，如果在首页的上方按钮区域没有新增“分类”、“标签”按钮，那么读者点开侧边栏看到了分类与标签会本能的点击，但是没有效果。如果首页添加了“分类”、“标签”按钮，用户点击了侧边栏，看到了分类与标签字样也是可以点击的，就会在一个页面出现重复的点击位置，用户体验不太好。修改方法将your blog dir／themes/next/layout/_macro/sidebar.swig的文件进行如下修改 修改前 12345678910111213141516&#123;% if site.categories.length &gt; 0 %&#125; &lt;div class="site-state-item site-state-categories"&gt; &#123;% if theme.menu.categories %&#125;&lt;a href="&#123;&#123; url_for(theme.menu.categories) &#125;&#125;"&gt;&#123;% endif %&#125; &lt;span class="site-state-item-count"&gt;&#123;&#123; site.categories.length &#125;&#125;&lt;/span&gt; &lt;span class="site-state-item-name"&gt;&#123;&#123; __('state.categories') &#125;&#125;&lt;/span&gt; &#123;% if theme.menu.categories %&#125;&lt;/a&gt;&#123;% endif %&#125; &lt;/div&gt;&#123;% endif %&#125;&#123;% if site.tags.length &gt; 0 %&#125; &lt;div class="site-state-item site-state-tags"&gt; &#123;% if theme.menu.tags %&#125;&lt;a href="&#123;&#123; url_for(theme.menu.tags) &#125;&#125;"&gt;&#123;% endif %&#125; &lt;span class="site-state-item-count"&gt;&#123;&#123; site.tags.length &#125;&#125;&lt;/span&gt; &lt;span class="site-state-item-name"&gt;&#123;&#123; __('state.tags') &#125;&#125;&lt;/span&gt; &#123;% if theme.menu.tags %&#125;&lt;/a&gt;&#123;% endif %&#125; &lt;/div&gt;&#123;% endif %&#125; 修改后12345678910111213141516&#123;% if site.categories.length &gt; 0 %&#125; &lt;div class="site-state-item site-state-categories"&gt; &lt;a href="&#123;&#123; url_for(theme.menu.categories+'/categories') &#125;&#125;"&gt; &lt;span class="site-state-item-count"&gt;&#123;&#123; site.categories.length &#125;&#125;&lt;/span&gt; &lt;span class="site-state-item-name"&gt;&#123;&#123; __('state.categories') &#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;&#123;% endif %&#125;&#123;% if site.tags.length &gt; 0 %&#125; &lt;div class="site-state-item site-state-tags"&gt; &lt;a href="&#123;&#123; url_for(theme.menu.tags+'/tags') &#125;&#125;"&gt; &lt;span class="site-state-item-count"&gt;&#123;&#123; site.tags.length &#125;&#125;&lt;/span&gt; &lt;span class="site-state-item-name"&gt;&#123;&#123; __('state.tags') &#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;&#123;% endif %&#125; 取消评论数显示启动“多说”的评论之后，会在博文标题下方增加一行“您有N条评论”的说明字样。对于一个长期的，相当一部分为小众技术类文字的博客来说，这个信息并不是非常重要。另外，考虑到多说的稳定性会影响到这里的显示（这几天就遇到了类似的问题），所以决定去掉显示。将your blog dir／themes/next/layout/_macro/post.swig的文件搜索duoshuo，删掉以下内容,删完后可用代替，以后可再加上123456789101112131415161718192021222324252627282930313233343536&#123;% if post.comments %&#125; &#123;% if (theme.duoshuo and theme.duoshuo.shortname) or theme.duoshuo_shortname %&#125; &lt;span class="post-comments-count"&gt; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &lt;a href="&#123;&#123; url_for(post.path) &#125;&#125;#comments" itemprop="discussionUrl"&gt; &lt;span class="post-comments-count ds-thread-count" data-thread-key="&#123;&#123; post.path &#125;&#125;" itemprop="commentCount"&gt;&lt;/span&gt; &lt;/a&gt; &lt;/span&gt; &#123;% elseif theme.facebook_comments_plugin.enable %&#125; &lt;span class="post-comments-count"&gt; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &lt;a href="&#123;&#123; url_for(post.path) &#125;&#125;#comments" itemprop="discussionUrl"&gt; &lt;span class="post-comments-count fb-comments-count" data-href="&#123;&#123; post.permalink &#125;&#125;" itemprop="commentCount"&gt;0&lt;/span&gt; comments &lt;/a&gt; &lt;/span&gt; &#123;% elseif theme.disqus_shortname %&#125; &lt;span class="post-comments-count"&gt; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &lt;a href="&#123;&#123; url_for(post.path) &#125;&#125;#comments" itemprop="discussionUrl"&gt; &lt;span class="post-comments-count disqus-comment-count" data-disqus-identifier="&#123;&#123; post.path &#125;&#125;" itemprop="commentCount"&gt;&lt;/span&gt; &lt;/a&gt; &lt;/span&gt; &#123;% elseif theme.hypercomments_id %&#125; &lt;!--noindex--&gt; &lt;span class="post-comments-count"&gt; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-comment-o"&gt;&lt;/i&gt; &lt;a href="&#123;&#123; url_for(post.path) &#125;&#125;#comments" itemprop="discussionUrl"&gt; &lt;span class="post-comments-count hc-comment-count" data-xid="&#123;&#123; post.path &#125;&#125;" itemprop="commentsCount"&gt;&lt;/span&gt; &lt;/a&gt; &lt;/span&gt; &lt;/span&gt; &lt;!--/noindex--&gt; &#123;% endif %&#125; &#123;% endif %&#125; 修改颜色样式在 next 主题文件里找到以下几个重要文件123highlight.styltheme.stylbase.styl 然后再找到你想要修改的东西去修改就好]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[我是谁]]></title>
    <url>%2F2016%2F10%2F09%2F%E5%8F%B9%E8%A8%80%2F%E6%88%91%E6%98%AF%E8%B0%81%2F</url>
    <content type="text"><![CDATA[最近几天没什么事，可以好好休息一下，所以就把对我是谁这个问题以前有过的想法整理整理。 对于唯心主义的三大问题之一，特别还是哲学问题，是没有答案的，或者说每个人都会有与别人不同的正确答案。那么就先对这个问题描述一下吧。 对于我是谁这个问题，随便找一个人问，估计大多都会回答，我是人这样子吧。但是人的定义是一个泛指，他并不是指个体，回答我是 人这个答案其实并没有正面回答，我是人的子集，（可能出现不是真子集的情况），所以所如何去定义我这个个体呢？ 现在很多人都会想到肉体，思想这些东西吧，那么首先就从肉体开始，举一个例子，哲学中一个很出名的特修斯之船，大意是这样，一艘船A，开始坏了船桨，于是给换了一个，A还是A吗？又过了很多年，船身也坏了，也给换掉了，A还是A吗？一直到最后，船的所有部分都给换掉了，那么A还是A吗？对于人的肉体也是一样，肉体无时无刻不在损坏，更新，可能你觉得这个幅度很小，那么看看婴儿的你和现在的你的照片，毫无疑问肉体有很大的变化，但是对此大多数人还是能毫不犹豫的回答说这就是我，那么，再往深处说，现在也有器官培养，修复。假如拿到了你的干细胞，培养成器官并且给别人换上，那么别人会变成你吗？更具有迷惑性的，未来如果用的基因克隆出另一个你，那么你和你的克隆谁才是你？ 上面一段是对于肉体来说，估计看到一半不到你就会觉得思想才是我，才是自己，毕竟有句话叫做我思故我在。关于思想这种的还又很多，比如精神，思维，灵魂，意识，我们就拿思想来做代表，这里就和人格同一性扯上了关系，因为灵魂也是具有变化性，很简单，一个人的思想变化是通过自己以前的思想来进行判断并进行改变，从这一点说，其实每个人都不具有独立思维，因为你的思维打一开始就都是从别人活着环境来的，即使是自己的判断，但是你所能判断，也是依靠着以前从别的地方获得来的。十年前的你，现在的你，五十年后的你，是否都是同一个你呢？恐怕你会回答那当然咯，这么回答也没有错，因为虽然思想是不断变化着的，但是你依然记得前一秒的自己，前几年的自己，也就是说存在思维链这个东西，所以你才那么肯定那就是我，如果采用这种说法，那么可以用弗洛伊德的话来说，你的过去只是你的记忆，虽然这句话听起来很偏激，但是不靠记忆你又怎么能证明前一秒的你就是现在的你呢？再举几个问题，一个突然失去记忆的人是否还能称作他自己？一个大脑受创的人突然性格大变是否还是他自己？ 那么，现在就可以说，我是谁这个问题，不能用自己的肉体或者是思想来定义，当然如果通过别人来告诉你就是你（很多人都是这么来定义自己的吧）就更可笑了。再往外扩展，一切的一切都是变化的，都是不能去准确的定义它到底是什么。所以我的个人观点是我是谁这个问题完全不重要啊，只要我觉得我是我就可以了。看到这里的你是不是很想打我呀？别急，听听我的解释吧，一个世界对于一个个体来说，存在的时间也就是这个个体从诞生到消亡的时间，你可能又会反驳我，地球存在这么多年。确实，地球存在很多年，但是对我这个给来说，它存在的时间也就是我能够感知到的时间，我诞生的时候，一切都诞生，我消亡的时候，一切都消亡（好中二啊。。），在我的认知中什么东西存在那它就是存在，我所不知道的都是不存在的（可能它以后又被我所知，那到那个时候它可能又被我定义为存在，从这个方面说它就很像薛定谔的猫，即存在又不存在，这在乎我的一念之间），这种唯我论的说法虽然很狂妄，但也确实存在。这种理论的核心应该就是自我对外界的感知吧，应为五感都是被转化为体内的信号才被自身感知，所以说如果没有了5感，你还能确定这个世界是存在的吗？ 不过，最近也不怎么信唯我论了，感觉太中二了，，现在看道德经，还有别的影响，倒是有这么一点感觉，所有的一切都是一个混沌，一个点，无所谓对错，分支，前进，差异。有点无为的意思在里面。]]></content>
      <categories>
        <category>叹言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[http文档]]></title>
    <url>%2F2016%2F04%2F16%2F%E5%B0%BA%E5%B7%A5%2Fhttp%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[HTTP协议码住 简介HTTP协议（Hyper Text Transfer Protocol，超文本传输协议）,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。HTTP基于TCP/IP通信协议来传递数据。HTTP基于客户端/服务端（C/S）架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。 特点（1）HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。（2）HTTP是媒体独立的：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。（3）HTTP是无状态：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 通信流程消息结构HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。 客户端请求消息：请求行、请求头部、空行和请求数据。 GET /hello.txt HTTP/1.1 User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3 Host: www.example.com Accept-Language: en, mi 服务端响应消息：状态行、消息报头、空行和响应正文。 HTTP/1.1 200 OK Date: Mon, 27 Jul 2009 12:28:53 GMT Server: Apache Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT ETag: &quot;34aa387-d-1568eb00&quot; Accept-Ranges: bytes Content-Length: 51 Vary: Accept-Encoding Content-Type: text/plain 请求方法GET 请求指定的页面信息，并返回实体主体。HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。PUT 从客户端向服务器传送的数据取代指定的文档的内容。DELETE 请求服务器删除指定的页面。CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。OPTIONS 允许客户端查看服务器的性能。TRACE 回显服务器收到的请求，主要用于测试或诊断。 状态码HTTP状态码分类 1** 信息，服务器收到请求，需要请求者继续执行操作2** 成功，操作被成功接收并处理3** 重定向，需要进一步的操作以完成请求4** 客户端错误，请求包含语法错误或无法完成请求5** 服务器错误，服务器在处理请求的过程中发生了错HTTP状态码列表 100 Continue 继续。客户端应继续其请求101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议200 OK 请求成功。一般用于GET与POST请求201 Created 已创建。成功请求并创建了新的资源202 Accepted 已接受。已经接受请求，但未处理完成203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域206 Partial Content 部分内容。服务器成功处理了部分GET请求300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI303 See Other 查看其它地址。与301类似。使用GET和POST请求查看304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源305 Use Proxy 使用代理。所请求的资源必须通过代理访问306 Unused 已经被废弃的HTTP状态码307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向400 Bad Request 客户端请求的语法错误，服务器无法理解401 Unauthorized 请求要求用户的身份认证402 Payment Required 保留，将来使用403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面405 Method Not Allowed 客户端请求中的方法被禁止406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权408 Request Time-out 服务器等待客户端发送的请求时间过长，超时409 Conflict 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息412 Precondition Failed 客户端请求信息的先决条件错误413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理415 Unsupported Media Type 服务器无法处理请求附带的媒体格式416 Requested range not satisfiable 客户端请求的范围无效417 Expectation Failed 服务器无法满足Expect的请求头信息418 当客户端给一个茶壶发送泡咖啡的请求时，茶壶就返回一个418错误状态码，表示“我是一个茶壶”。500 Internal Server Error 服务器内部错误，无法完成请求501 Not Implemented 服务器不支持请求的功能，无法完成请求502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事件监听传参]]></title>
    <url>%2F2015%2F10%2F05%2F%E5%B0%BA%E5%B7%A5%2F%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[前言以前一直不懂怎么给eventlistener传参数，并且能解绑，网上也没查到，今天js群有一位前辈给了答案，在此记录 方法123456789101112131415window.onload = function () &#123; var a = document.getElementById('div1') a.addEventListener('click', handle)&#125;function handle(e) &#123; //取参 var val = document.getElementById('div0') //调用 f(e, val)&#125;function f(e, val) &#123; console.log(e, val)&#125;]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[npc]]></title>
    <url>%2F2015%2F08%2F19%2F%E5%8F%B9%E8%A8%80%2Fnpc%2F</url>
    <content type="text"><![CDATA[曾经有过这样的想法，在这个世界上，除自己以外的人全部都是NPC。 这个想法其实差不多就是世界只有自己一个人，这和宇宙的中心就是自身这个说法相合。其他的人只是高智能高仿真的NPC，他们对你来说只是可以用来接任务升级的存在。 我不知道的东西一概可以不存在 世界其实并没有全部运行着，他只是存在于你能够触碰到的角落，比如我楼下的人家，现在我没有去他们家，我不知道他们存不存在。这时候世界为了节省能源，可能就会关闭它的存在，它只有结构存在，里面的一切东西都虚无化。然而当你去敲门的时候，这一切都会在你敲门的瞬间回来，所以当你敲门的时候，你可能会看到一张带着深深的厌恶和不耐烦给你开门的脸。 其实这个和那个虐猫狂人的说法很像，你不知道那只猫的死活，只有当你打开盒子的时候才知道，在那之前都是一片虚无。 如果这个成立的话， 那么你的人生不过是上帝开的一盘单机人生模拟游戏，他可能玩到一半角色被车撞，然后你就死掉，也可能到最后老死，不过他肯定会有玩完的那一天，所以我们终究会有死的那一刻。所以作为角色的自己只能希望上帝是个高玩233333 以上都是我自己胡扯]]></content>
      <categories>
        <category>叹言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计原则]]></title>
    <url>%2F2015%2F07%2F10%2F%E5%B0%BA%E5%B7%A5%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[亲密对齐重复对比一本设计书上看到的，网页设计的三个概念，觉得不错就记一下，不过没有什么demo。 亲密：将相关的元素放在一起，可根据功能性，相似性，重要性等，来实现更好的组织布局，同时要避免过多的分组，孤立的元素，无意义的留白。对齐：老用居中不好，试试别的，可以用画线来增强感觉，线来进行块分，白纸黑线意外的有表现力，避免多种对齐方式同时使用重复：巧妙使用，和音乐里面的重复样的对比：这个用的很多了，不过得注意下颜色颜色这个我觉得其实是最重要的了吧，颜色给人的感觉，象征，暗示，根据使用情况搭配，虽然看过一些颜色的书，但是对这个还是不怎么会。。]]></content>
      <categories>
        <category>尺工</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一只风扇和一群风扇]]></title>
    <url>%2F2015%2F06%2F20%2F%E5%8F%B9%E8%A8%80%2F%E9%A3%8E%E6%89%87%20%2F</url>
    <content type="text"><![CDATA[关于群居和独居：独居具有完全的自由，自主，自我。相比群居，没有阶级性，社会性，所依赖的只是自己的能力。而如果是群居，打个比方。一群狼抓到一只鹿（一般鹿都是扮演被抓的嘛），然后，并非是抓到的人能先吃或吃的多。反而是群体的长者或者说是领导能够享受这个权利，然后依次按阶级向下，不过，这种应该还算好的，抓到鹿的那只狼不会是最后吃或者是没吃的那一群体。然而在人类社会，应为有了语言这一独特属性，会有各种戏剧性的事情，会谄谀讨好高位的无能力者，高位的裙带关系着，高位在意的着，这些毫无疑问百分之80的会排在有能力着之前，除了这些，如果能力者对周围的态度和关系如果哪一环除了错，也会导致吃不着。 这种出力不讨好的行为是显然的，但是确实广泛的存在的，为什么呢。 能力者的能力并不完善，比如他只有捕捉的能力而并没有找住处，防范危险，寻求配偶等等的能力，所以他通过依赖于群里通过自己捕捉的能力换取群体中的其他自己达不到的报酬（归所，羁绊，温暖，赞美，羡慕，） 能力者受制于更高能力者，也就是所谓的挟制。 能力者 为了某人因为某个原因而心甘情愿。 以上分别占80,，，，19，，，1，，，没有根据 说到底群体是因为个体的弱小而形成的。群体中的各个分子都能依赖于各样的东西而从群体中换到自己想要的东西。就像是每人都有自己的东西卖，而群体就是提供场所的市场，通过它在个体数目足够多的情况下能够满足每个个体各种各样的需求。 但是为什么像人类这么大的群体，人还是会说自己孤独呢。 是没有同类导致的孤独吗，然而这么大的世界同类是绝对会有的。 是得不到归属感吗，有可能。 是自己的欲望不能满足吗，这句话其实不能理解为自己的，因为大多不能满足的欲望中大部分都是有强加在别的个体上的某些要求和期待，当他们没能按照自己所想做的时候就会产生分歧，导致自己欲望落空，从而产生自己和别人的意见不同，自己是特别的，只有自己才这么想，所以自己是孤独的，这种当事人误以为自己是没有同类的孤独其实 只是自己强加的欲望没有实现罢了。 但是。群体之间的联系纽带不就是这种互相的需求吗？这正是群体之间存在的证明，那么这么说，由于一个人不可能总是由别人妥协，自己欲望达成。 所以可以得出结论在群体之中的人一定会感到孤独。 不过难道孤独就是不好的，就是错误的吗？并不是，例子是这世界上的哲学家全部都享受这孤独，甚至去追寻这个玩意。有个哲学家（玄学）说过这样的话，离群索居之人不是野兽便是神明，虽然不知道他的依据，不过我的认同率在50之间，因为我觉得人是势必要孤独的，必定要有离群的时刻的。但是即使离开了，也不是真正的离开吧。]]></content>
      <categories>
        <category>叹言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[九州]]></title>
    <url>%2F2015%2F02%2F25%2F%E6%9D%82%E4%B9%B1%2F%E4%B9%9D%E5%B7%9E%2F</url>
    <content type="text"><![CDATA[为卿采莲兮涉水，为卿夺旗兮长战，为卿遥望兮辞宫阙，为卿白发兮缓缓歌。 昨日青丝，冢间红骨； 月色晚来枯，吊唱相和无； 悲喜总无泪也，是人间白发，剑胆成灰；琴木萧萧也，弦尽时秋风悲回，莫问从头； 英雄总无路，天下千年酒，不解此一愁。 我有屠龙之术，欲翻流云起舞；我有苍茫之志，欲煎七海成田；我怀绝世之锋，欲解抵天之柱；我是藏玉之璞，欲觅神匠成材。吾曾笑云梦乡里文皇帝，长生何须吞白玉；吾曾笑长锋空折武皇帝，挥军难渡雪河西。吾不惧青天之高，黄地之厚；独恨不逢琢玉手，晚生不见凤凰来。噫嘘兮，山之既高，神女空候；水之既深，龙死荒滩。 繁花落尽时,冥云散去间.长风啸雄骑,狂日逐波澜.血满英雄路,功成万骨枯.梦醒花犹存,铁甲依然在.]]></content>
      <categories>
        <category>杂乱</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[wind_song听后感]]></title>
    <url>%2F2014%2F11%2F03%2F%E5%8F%B9%E8%A8%80%2Fwind-song%E5%90%AC%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[被飞吹走的你啊，现在漂到了哪里呢。快回来吧，你的故乡在这里啊。那些存在过的回忆被你放在哪里了呢？多怀恋我们在一起欢笑的那些日子啊。回来吧，这里有牵挂你的人呐。别害怕，没有人会欺负你的呢。 被风吹走的你啊，在外面一定很艰难吧。我是明白的，你那近似于倔强的坚强。小时候你就一直如此呢。眼泪从来不让人看到，总是咬紧牙口，握紧拳头。别灰心，总是会有人爱你的啊。向前走，你会看到越来越广阔的风景的。 被风吹走的你啊，能否看见我的这份思恋呢。同在一片天空下的我们，却看着不一样的风景。我一直等待着，等待着疲倦的你的归来。等到那个时候，我一定露出最棒的微笑，这笑容将抚平你那杯风吹走的年华。]]></content>
      <categories>
        <category>叹言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[让自己不那么困]]></title>
    <url>%2F2014%2F06%2F16%2F%E6%9D%82%E4%B9%B1%2F%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B8%8D%E9%82%A3%E4%B9%88%E5%9B%B0%2F</url>
    <content type="text"><![CDATA[关于让自己不那么困，以及提高能高效处理事情时间的小想法减少信息的摄取可以有效的防止干扰，提高大脑专注度以及效率。也会使自己轻松一些。所以平常的话可以在不影响自身及周围的情况下减少对五感的使用，主要就是听觉和视觉这2者。 解决听觉主要可以通过耳机或者深度专注视觉主要是光线对眼睛的影响。避免光差太大这种原因。尽量使用暖光。其实最好的就是在深夜。这种时候黑夜会自动帮助你屏蔽周边事物，降低需要处理的信息（其实这种也可以通过刻意摆放自己目所能见物品的位置来利用。我们都知道将东西放在身边来提醒自己，现在则是反过来）因为看到一件东西后，会传递光，然后大脑要进行识别判断，这只是最简单的，如果物品含有特殊意义的话那就更麻烦，会进行联想，这会很大程度的降低专注度。 现在年纪大了，，，，也不是那么喜欢深夜了，还是得早点睡。扛不住啊，每天早上被手机闹钟吵醒的时候，真的是超烦，啥都不想关了继续睡。。所以现在不得不设置2个闹钟，免的第一个被迷迷糊糊的我关掉了还不知道闹钟响过。。闹钟的提醒话设置的是以前在街上看到的一个很鸡汤的句子， 叫醒你的是什么? 现在看到这个真的汗颜。。]]></content>
      <categories>
        <category>杂乱</category>
      </categories>
  </entry>
</search>
