---
title: 日常小技巧（五）
categories:
  - 尺工
date: 2018-09-09 16:52:40
---
<p></p>
<!-- more -->

## promise

### 执行顺序
```js
setTimeout(()=>{console.log(3)},0)
Promise.resolve().then(()=>{console.log(2)})
console.log(1)

/*
* 1
* 2
* 3
*/
```

执行顺序类似 宏任务 微任务 => 宏任务[异步] 微任务 [参考](https://github.com/creeperyang/blog/issues/21)

**promise 确实是异步，只是类似于一个微任务 micro task**


### microtask
promise.then
MutationObserver

**process.nextTick 执行在 microtask 之前，task 之后，它不是 microtask**
```
new Promise((res) => {
  console.log(1)
  res()
}).then(() => console.log(2))

process.nextTick(() => console.log(3))

// 132
```

### promise 链式调用返回值
**[primise 规范](https://promisesaplus.com/#point-26)**

- then must return a promise.

- promise2 = promise1.then(onFulfilled, onRejected);

  - If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x).
  - If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.
  - If onFulfilled is not a function and promise1 is fulfilled, promise2 must be fulfilled with the same value as promise1.
  - If onRejected is not a function and promise1 is rejected, promise2 must be rejected with the same reason as promise1

### promise 兼容实现
查了一下有[文章](https://zhuanlan.zhihu.com/p/34421918)说是在执行 then 的时候会有一个 immediate 执行，利用 MutationObserver 这个去做检测
自己用 babel-pollyfill 看了一下，里面有这么一段代码，感觉这个 notify 方法就是用作 microtask / job 的。

```js
// Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if (Observer) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }
```


## typeof
```
Value               function   typeof
-------------------------------------
"foo"               String     string
new String("foo")   String     object
1.2                 Number     number
new Number(1.2)     Number     object
true                Boolean    boolean
new Boolean(true)   Boolean    object
new Date()          Date       object
new Error()         Error      object
[1,2,3]             Array      object
new Array(1, 2, 3)  Array      object
new Function("")    Function   function
/abc/g              RegExp     object
new RegExp("meow")  RegExp     object
{}                  Object     object
new Object()        Object     object 
```

## document.elementFromPoint
获取某个坐标的位置对应的 dom。支持性贼好。。

## clientHeight offsetHeight scrollHeight
clientHeight 为不包括 border,滚动条的视口内高度，offsetHeighta 为包括上面那些的高度，scrollHeight 为包括内容滚动区域的所有高度

## vertical-align
当在这样的一个结构时，特别是第二个 span 设置为了 bfc 盒子的时候，会出现某些问题，两行文字对不齐
```html
<p>
  <span>1</span>
  <span>2</span>
</p>
```
这个时候可以设置第一个 span 的 `vertical-align: top` 来解决这个问题

或者给第二个 span 设置增加 `vertical-align: bottom`

这个问题的原因是当成为 bfc 盒子之后，它的对齐方式会改变,此时是整个这个盒子 span2 相对于基线对齐，而 span1 则是盒子里面文字本身相对与于基线对齐。

[张鑫旭大佬有一篇文章讲对比较细](https://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/comment-page-1/)

里面有一句比较重要的话

`The baseline of an ‘inline-block’ is the baseline of its last line box in the normal flow, unless it has either no in-flow line boxes or if its ‘overflow’ property has a computed value other than ‘visible’, in which case the baseline is the bottom margin edge.`

谷歌翻译如下

`“内联块”的基线是正常流程中其最后一个线框的基线，除非它没有流入线框或者其“溢出”属性具有“可见”以外的计算值， 在哪种情况下，基线是底部边缘边缘。`

张鑫旭大佬翻译如下

`’inline-block’的基线是正常流中最后一个line box的基线, 除非，这个line box里面既没有line boxes或者本身’overflow’属性的计算值不是’visible’, 这种情况下基线是margin底边缘。`

`一个inline-block元素，如果里面没有inline内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘，否则，其基线就是元素里面最后一行内联元素的基线。`

## ios bug
1. 全局设置对 `user-selected: *` 会使 input textarea 不能被选中，弹起输入框
2. fixed 在部分ios手机中，滑动对时候会消失，滑动停止后又出来。解决方法可以将 fixed 区域整个拿出来，不放在滚动区域内，或者设置如下。
```
.fixed{
  transform: translate3d(0,0,0);
}
.fixed * {
  transform: translate3d(0,0,0);
}
```
3. 滚动区域卡顿，设置`-webkit-overflow-scrolling: touch;`

4. ios 默认滑动可以弹出正常网页区域，出现空白。解决可以整个页面禁止滑动，让滚动条不出现，或者用三方库 iscroll 之类的


## m3u8
对于这种格式的视频，需要给设置 video 的source 为 `<source src="video.url" type="application/x-mpegURL"></source>` 在电脑上不支持播放

## promise
promise.then().catch().finally()

finally 有兼容，很多没有实现这个功能

当链式调用中没有参数【回调函数】时会返回传入的 promise 对象
，有【回调函数】作参数时会返回【一个返回值为回调函数 return 的值的 promise 对象】传给下一个链式调用
 