---
title: 贪吃蛇(二)
categories:
  - 尺工
date: 2017-10-26 14:40:00
---
<p></p>
<!-- more -->

## queue 组件
贪吃蛇中最重要的就是一个跟随队列的实现，即每一个小方块总是跟着前一个的移动，具体逻辑就是保存每一个小块的位置和转动信息，然后下一个块去读取它前面一个的信息，判断之后存入。

## 实现
首先为了保证能取到上一个的值，注册了一个系统来保存信息。

存储结构为数组的数组，第一个数组表示有多少组位置信息，第二个数组表示每一组信息内的详细信息，同时规定一个详细信息的最大长度，超过之后就舍去，避免形成数据特别庞大的数组。
```
AFRAME.registerSystem('queue', {
  init() {
    var me = this;
    me.position_recording = [];
    me.rotation_recording = [];
  },
  add_queue() {
    var me = this;
    me.position_recording.push([]);
    me.rotation_recording.push([]);
  },
})
```
每多一个尾巴新增一个数组记录它的信息。同时给每一个块标上序号，对应其信息存储在数组从小到大的顺序。组件初始化函数如下
```
init() {
  var me = this,
    current_position = {},
    current_rotation = {};
  //设置id
  me._id = me.system.position_recording.length;
  me.system.add_queue();
  //设置初始位置
  if (me.data.ishead) {
    me.Copy(me.el.getAttribute('position'), current_position);
    me.Copy(me.el.getAttribute('rotation'), current_rotation);
  } else {
    current_position = me.system.position_recording[me._id - 1][0];
    current_rotation = me.system.rotation_recording[me._id - 1][0];
    me.el.setAttribute('position', current_position);
    me.el.setAttribute('rotation', current_rotation);
    this.el.setAttribute('visible', true)
  }
  me.system.position_recording[me._id].unshift(current_position);
  me.system.rotation_recording[me._id].unshift(current_rotation);
},
```

### 问题1
下一个滑块应该取上一个滑块的什么位置,在每一个tick里面，滑块的信息都会跟新并unshift到数组对应的数组中存储，下一个滑块要和前一个滑块保持一定的距离，不能太远也不能太近。

tick 中首先存储信息，存储时对于相同的数据不存储，之后对尾巴进行判断，取上一个盒子的第[frame]个数据进行判读，目标位置和上一个盒子的现在位置是否有一定的距离间隔，没有则保持静止，有间隔之后更新位置并存储

这里出现了一个很大的问题，distance 设置的值要和 frame 设置的值有所对应，frame 设置之后一定要保证距离大于 distance 的设置。
一般来说 distance 是不会触发，但是如果快速旋转的话有可能导致位置不变
```
tick() {
  var me = this;

  if (me.data.ishead) {
    me.DeduplicationStore();
    return;
  }
  if (me.system.position_recording[me._id - 1].length > me.data.frame) {
    var target_position = me.system.position_recording[me._id - 1][me.data.frame],
      last_current_position = me.system.position_recording[me._id - 1][0],
      target_rotation = me.system.rotation_recording[me._id - 1][me.data.frame];
    if (me.Distance(last_current_position, target_position)) {
      me.el.setAttribute('position', target_position);
      me.el.setAttribute('rotation', target_rotation);
      me.DeduplicationStore();
    }
  }
},
Distance(target, current) {
    var flag = false,
      result = 0;
    result = Math.sqrt(Math.pow((target.x - current.x), 2) + Math.pow((target.y - current.y), 2) + Math.pow((target.z - current.z), 2));
    if (result > this.data.distance)
      flag = true;

    return flag;
  },
  //去掉重复的位置后存储移动轨迹
  DeduplicationStore() {
    var me = this,
      current_position = {},
      current_rotation = {},
      last_position = {},
      is_equel;

    me.Copy(me.el.getAttribute('position'), current_position);
    me.Copy(me.el.getAttribute('rotation'), current_rotation);

    me.Copy(me.system.position_recording[me._id][0], last_position);
    is_equel = me.Equel(last_position, current_position);
    if (!is_equel) {
      me.system.position_recording[me._id].unshift(current_position);
      me.system.rotation_recording[me._id].unshift(current_rotation);
    }
    if (me.system.position_recording[me._id].length > me.data.frame + 1) {
      me.system.position_recording[me._id].pop();
    }
  },
```

## 总结
这个组件写的时候不是很清楚，出了很多错，数据存储的时候出了顺序问题，跟随的时候距离设置出了问题，初始化距离出问题。。。花了很多时间调这个。

这个就是最主要的组件，其他还有 food，eat 组件，foot设置食物的属性，加速度或者体型 eat 绑定碰撞检测，碰撞后销毁 food 对应的 dom，并添加对应属性



