---
title: 贪吃蛇(一)
categories:
  - 尺工
date: 2017-10-26 09:35:11
---
<p></p>
<!-- more -->
## 前言
一个 3d 的贪吃蛇。。

## 想法
最开始的时候是想做一个多人对战的贪吃蛇游戏，可以吃小方块（可以变大，加速等），然后吃到别的蛇会把别人咬断，时限过后分最高的人获胜。

### 网络同步
然后就开始偏离了原方向，游戏本体一点都没做而先去想多人实时对战的问题，最开始是打算能否直接用 IM 来发送相关消息进行实时通讯。用了网易云的通讯，小量的话免费而且文档还可以，比起辣鸡融云要好很多。不过接着往下了解的时候发现用 IM 去做的话不现实，因为没有服务端的判断，而客户端的信息都是不可信的，所以舍弃了 IM 的想法，相关资料如下

[ow的网络同步](http://gad.qq.com/article/detail/28682)
关键术语： 帧同步
关键问题： 发生丢包或延迟情况下依然能显示正确的逻辑
我的理解是在客户端有两套逻辑，一套预测的和一套实际显示的，当你按下移动键时，客户端脚本会预测你的移动，并形成一个系列帧（正在向前走），并发送给服务端，服务端这时候同意判断，比如你是否被打死了，如果打死了则是不能移动的，再传回客户端，客户端这个时候纠正之前的预测并显示到画面上。在这个过程中如果网络不好，即没有及时的收到服务端的纠正，那么客户端就会沿用向前走的预测，并在收到服务端的纠正后再回退到预测时的那一帧，这就是玩游戏网卡时经常能看到的人物都自动在走，过了一会突然发生位移或者死人。

看到这的时候突然发现自己好像偏太远了。。游戏本体都没有，至少应该先做个单机版的再说，于是就把这个放着了。

### 3d 框架
这之后开始想游戏实现，这之前有看了一点 A-FRAME 的相关使用，所以想着能不能用 A-FRAME 来实现，毕竟 THREE.JS 比较麻烦，需要去控制的东西很多。但是使用的时候还是发现有很多问题。A-FRAME 的自由度肯定是没有 three 多，如果想实现一些和官方不太一样的组件就都得自己去写。中间犹豫几次到底用哪个，最后还是选了 A-FRAME，又好好的去看了看文档，然后开始写。

### A-FRAME 使用
A-FRAME 内置很多组件，每个组件里面又有很多的控制参数，所以推荐直接去看 NPM 下的 A-FRAME 包，src 文件夹下的对应文件，写的很清楚。每个组件都有开启和关闭，enable。基本元件是 `<a-entity>` 不过它有很多封装了的元件 `<a-box> <a-camera>` 等，这些元件都有默认绑上去的其他组件，比如`position look-controls wasd-control` 等。

一些认为比较实用的设置
`<a-scene>` 的 `embedded ` 设置 `false` 之后`<a-scene>`就不是全屏而是外层 div 的大小

`<a-camera>`的 `wasd-controls` 设置`fly:true`之后就可以全方位移动，而不是只能水平移动

另外官方有推荐很多其他的插件，和 vue-awesome 一样，有个 [awesome-aframe](https://github.com/aframevr/awesome-aframe/blob/master/ARCHIVE.md),里面有很多相关的组件
有2个组件觉得比较好，一个是动画组件`aframe-animation-component`,另一个是物理引擎组件`aframe-physics-system`基本上这个官方的综合库里面就够用了
[A-Frame Extras](https://github.com/donmccurdy/aframe-physics-system)

用 physics 的时候还遇到个坑。。按照官网给的检测碰撞的事件写了之后并不触发，找了好久没找到，也提了 issues，本来都快放弃了，，最后找到问题是版本太低，，作者刚好在这几天修复检测碰撞的这个事件调用。。。

## 逻辑
准备工作差不多到这里就完了，然后开始是实际编写时候遇到的一些问题
首先因为自带的 wasd-controls 不能达到贪吃蛇的移动方式，于是就照着它写了一个 walk 组件，没有改多少，只是在 tick 中增加了 z 坐标的移动。写的时候发现官方组件的写法很厉害。。比如下面这个
```
var KEYS = [
  'KeyW', 'KeyA', 'KeyS', 'KeyD',
  'ArrowUp', 'ArrowLeft', 'ArrowRight', 'ArrowDown'
];
{
  init(){
  this.onKeyDown = bind(this.onKeyDown, this);
  }
  onKeyDown(event) {
    var code = event.code;
    if (KEYS.indexOf(code) !== -1) {
      this.keys[code] = true;
    }
  },
  play() {
    this.attachKeyEventListeners();
  },

  pause() {
    this.keys = {};
    this.removeKeyEventListeners();
  },

  remove() {
    this.removeKeyEventListeners();
  },

  attachKeyEventListeners() {
    window.addEventListener('keydown', this.onKeyDown);
  },

  removeKeyEventListeners() {
    window.removeEventListener('keydown', this.onKeyDown);
  },
}
```
首先是按键的绑定，这种对应的方法觉得很巧妙
```
if (KEYS.indexOf(code) !== -1) {
  this.keys[code] = true;
}
```
首先是利用数组查找对应按键，再给keys对象添加一个对应属性。

另外还有一个很厉害的绑定事件方法，以下是源码
```
/**
 * Faster version of Function.prototype.bind
 * @param {Function} fn - Function to wrap.
 * @param {Object} ctx - What to bind as context.
 * @param {...*} arguments - Arguments to pass through.
 */
module.exports = function bind (fn, ctx/* , arg1, arg2 */) {
  return (function (prependedArgs) {
    return function bound () {
      // Concat the bound function arguments with those passed to original bind
      var args = prependedArgs.concat(Array.prototype.slice.call(arguments, 0));
      return fn.apply(ctx, args);
    };
  })(Array.prototype.slice.call(arguments, 2));
};
```
它将原来绑给 window 对象的方法给转到了绑了该组件的 dom 上。不过这段代码其实没怎么看懂。。
以及另外一个需要注意的，在复杂结构运算时需要对对象进行copy，不然很容易修改赋值会改变原来对象而出现很多想不到的问题。
移动需要注意的两点
1. 使用向量去进行移动运算，方便进行同时按下多方向的判断
2. 全局坐标系和当前坐标系的转换

没写完的留下一次吧。。感觉好多